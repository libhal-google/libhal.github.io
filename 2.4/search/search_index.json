{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udfe1 Home","text":"Welcome to libhal"},{"location":"#abstract","title":"Abstract","text":"<p>libhal exists to make hardware drivers \ud83d\ude9a portable, \ud83e\uddbe flexible, \ud83d\udce6 accessible, and \ud83c\udf70 easy to use. libhal seeks to provide a foundation for embedded drivers, allowing those drivers to be used across different processors, microcontrollers, systems, and devices.</p> <p>The design philosophy of libhal is to be:</p> <ol> <li>Portable &amp; Cross Platform</li> <li>Light Weight</li> <li>General</li> <li>Minimalist</li> <li>Safe &amp; Reliable</li> <li>Tested &amp; Testable</li> <li>Compiled Quickly</li> <li>OS Agnostic</li> </ol>"},{"location":"#the-basics","title":"The Basics","text":"<p>libhal, at its core, is simply a set of interfaces that correspond to hardware devices and peripherals. These interfaces use runtime polymorphism in order to decouple application logic from driver implementation details. This decoupling enables applications to run on any platform device that has the necessary components available.</p> <p>A quick example is a blinker program. The required interfaces for such a program is a <code>hal::output_pin</code> for controlling the LED and a <code>hal::steady_clock</code> for keeping time. Now your application takes both of these drivers without having to consider their implementation details and blink and LED at a specified interval.</p>"},{"location":"#support","title":"Support","text":"<ul> <li>libhal discord server (preferred)</li> <li>GitHub issues</li> <li>Cpplang Slack #embedded channel</li> </ul>"},{"location":"#distribution","title":"Distribution","text":"<ul> <li>Conan package manager</li> <li>Source code is hosted on GitHub</li> <li><code>vcpkg</code> package manager (planned for the future)</li> </ul>"},{"location":"#sponsorships","title":"Sponsorships","text":"<p>We are proud to be sponsored by JFrog. JFrog generously provides us with free artifact management, security, and CI/CD tools, allowing us to focus on the success of our project.</p> <p>We are grateful for their support and contribution to the open source community. Thank you, JFrog!</p> <p>For more information about JFrog's community initiatives, visit their Giving Back page.</p>"},{"location":"getting_started/","title":"\ud83d\ude80 Getting Started","text":""},{"location":"getting_started/#install-prerequisites","title":"\ud83e\uddf0 Install Prerequisites","text":"<p>What you will need in order to get started with libhal.</p> <ul> <li><code>make</code>: latest available version</li> <li><code>cmake</code>: 3.15 or above</li> <li><code>python</code>: 3.10 or above</li> <li><code>conan</code>: 2.0.13 or above</li> <li>Suitable Compiler for running host tests (can be either of these):</li> <li><code>gcc</code>: 11.3.0 or above</li> <li><code>clang</code>: 14 and above</li> </ul> Ubuntu 22.04Ubuntu 20.04MacOS XWindows <p>Python 3.10 is default installed, no need to install it.</p> <p>Install GCC, make (from build essentials):</p> <pre><code>sudo apt update &amp;&amp; sudo apt upgrade\nsudo add-apt-repository -y ppa:ubuntu-toolchain-r/test\nsudo apt install -y build-essential g++-11\n</code></pre> <p>Install <code>clang-tidy-16</code>:</p> <pre><code>wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -\nsudo add-apt-repository \"deb http://apt.llvm.org/jammy/ llvm-toolchain-jammy-16 main\"\nsudo apt-get install clang-tidy-16\n</code></pre> <p>Installing conan &amp; cmake:</p> <pre><code>python3 -m pip install \"conan&gt;=2.0.13\" cmake\n</code></pre> <p>Install python3.10, GCC, and make (from build essentials):</p> <pre><code>sudo apt update &amp;&amp; sudo apt upgrade\nsudo add-apt-repository -y ppa:ubuntu-toolchain-r/test\nsudo apt install -y build-essential g++-11 python3.10\n</code></pre> <p>Install <code>clang-tidy-16</code>:</p> <pre><code>wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add -\nsudo add-apt-repository \"deb http://apt.llvm.org/focal/ llvm-toolchain-focal-16 main\"\nsudo apt-get install clang-tidy-16\n</code></pre> <p>Installing conan &amp; cmake:</p> <pre><code>python3.10 -m pip install \"conan&gt;=2.0.13\" cmake\n</code></pre> <p>Install Homebrew:</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>Install latest version of Python 3.x &amp;&amp; llvm:</p> <pre><code>brew install python llvm\n</code></pre> <p>Install conan &amp; cmake:</p> <pre><code>python3 -m pip install \"conan&gt;=2.0.9\" cmake\n</code></pre> <p>Make <code>clang-tidy</code> available on the command line:</p> <pre><code>sudo ln -s $(brew --prefix llvm)/bin/clang-tidy /usr/local/bin/\n</code></pre> <p>Install conan &amp; cmake:</p> <pre><code>python3 -m pip install \"conan&gt;=2.0.13\" cmake\n</code></pre> <p>Install Rosetta (only required for M1 macs):</p> <pre><code>/usr/sbin/softwareupdate --install-rosetta --agree-to-license\n</code></pre> <p>Rosetta necessary for intel based cross compilers:</p> <p>We recommend using the <code>choco</code> package manager for windows as it allows easy installation of tools via the command line.</p> <p>To install <code>choco</code>, open PowerShell as an administrator and run the following command:</p> <pre><code>Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n</code></pre> <p>Tip</p> <p>If the <code>choco</code> command doesn't work after running this script try closing and opening again PowerShell.</p> <p>Now install <code>python</code>, <code>gcc</code> (via mingw), <code>make</code> (for cmake):</p> <pre><code>choco install python mingw make\n</code></pre> <p>Install clang-tidy 16 (via llvm):</p> <pre><code>choco install llvm --version=16.0.6\n</code></pre> <p>Installing conan &amp; cmake:</p> <pre><code>python3 -m pip install -U \"conan&gt;=2.0.13\" cmake\n</code></pre>"},{"location":"getting_started/#setting-up-conan","title":"\ud83d\udd27 Setting up Conan","text":"<p>Add the <code>libhal-trunk</code> repository to your system. This repository holds all of the libhal packages.</p> <pre><code>conan remote add libhal-trunk https://libhal.jfrog.io/artifactory/api/conan/trunk-conan\n</code></pre> <p>Next, install the libhal <code>settings_user.yml</code> which extends the architectures of conan's <code>settings.yml</code> file to include baremetal architectures. These additional architecture definitions are required for ALMOST ALL libhal applications.</p> <pre><code>conan config install -sf profiles/baremetal https://github.com/libhal/conan-config.git\n</code></pre> <p>Next, setup the host profile. Host profiles define the compiler, compiler version, standard library version, and many other settings used to configure how applications are built.</p> <p>First detect the default. This will be overwritten in the next step.</p> <pre><code>conan profile detect --force\n</code></pre> <p>Now install the profile for your particular OS and CPU architecture.</p> Intel LinuxARM64 LinuxM1 MacIntel MacIntel WindowsARM64 Windows <p>If your host machine is using an intel core processor as its CPU then you'll want to use this default configuration.</p> <pre><code>conan config install -sf profiles/x86_64/linux/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>It is less likely your host desktop is an ARM64. This section is mostly for building applications and tests on a Raspberry PI or other SBC. But if you do have a laptop powered by an ARM64 core, then this is the correct configuration for you.</p> <pre><code>conan config install -sf profiles/armv8/linux/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>If your Mac Book uses an M1 processor then you'll want to use this default configuration.</p> <pre><code>conan config install -sf profiles/armv8/mac/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>If your Mac Book uses an Intel processor then you'll want to use this default configuration.</p> <pre><code>conan config install -sf profiles/x86_64/mac/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>If your Windows machine uses an Intel processor then you'll want to use this default configuration.</p> <pre><code>conan config install -sf profiles/x86_64/windows/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>If you have a modern surface laptop with ARM64, then this may be the right choice for you (this profile is untested).</p> <pre><code>conan config install -sf profiles/armv8/windows/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre>"},{"location":"getting_started/#building-demos","title":"\ud83d\udee0\ufe0f Building Demos","text":"<p>Clone the target library you would like to run the demos for. You can download just one or both if you have both devices.</p> LPC4078STM32F103 <pre><code>git clone https://github.com/libhal/libhal-lpc40\ncd libhal-lpc40/demos\n</code></pre> <pre><code>git clone https://github.com/libhal/libhal-stm32f1\ncd libhal-stm32f1/demos\n</code></pre> <p>This command will install the profiles for the ARM cortex processor and LPC40 series microcontrollers. The LPC40 microcontrollers are: <code>lpc4072</code>, <code>lpc4074</code>, <code>lpc4076</code>, <code>lpc4078</code>, and <code>lpc4088</code>.</p> <p>The LPC40 profiles import <code>cortex-m4</code> and <code>cortex-m4f</code> profiles from the ARM cortex processor library <code>libhal-armcortex</code> and thus need to be installed as well.</p> LPC4078STM32F103 <pre><code>conan config install -sf conan/profiles/ -tf profiles https://github.com/libhal/libhal-armcortex.git\nconan config install -sf conan/profiles/ -tf profiles https://github.com/libhal/libhal-lpc40.git\n</code></pre> <pre><code>conan config install -sf conan/profiles/ -tf profiles https://github.com/libhal/libhal-armcortex.git\nconan config install -sf conan/profiles/ -tf profiles https://github.com/libhal/libhal-stm32f1.git\n</code></pre> <p>To build using conan and cmake, you just need to run the following:</p> LPC4078STM32F103 <pre><code>conan build . -pr lpc4078 -s build_type=MinSizeRel\n</code></pre> <pre><code>conan build . -pr stm32f103 -s build_type=MinSizeRel\n</code></pre> <p>Note</p> <p>You may need to add the argument <code>-b missing</code> at the end of the above command if you get an error stating that the prebuilt binaries are missing. <code>-b missing</code> will build them locally for your machine. After which those libraries will be cached on your machine and you'll no longer need to include those arguments.</p> <p>To build a binary for a particular microcontroller, you need to specify the microcontroller you plan to target such as the <code>lpc4078</code> and the build type.</p> <p>Each microcontroller has different properties such as more or less ram and the presence or lack of a floating point unit.</p> <p>The following build types, <code>build_type</code> argument are available:</p> <ul> <li>\u274c Debug: No optimization, do not recommend, normally used for unit   testing.</li> <li>\ud83e\uddea RelWithDebInfo: Turn on some optimizations to reduce binary size and   improve performance while still maintaining the structure to make   debugging easier. Recommended for testing and prototyping.</li> <li>\u26a1\ufe0f Release: Turn on optimizations and favor higher performance   optimizations over space saving optimizations.</li> <li>\ud83d\udddc\ufe0f MinSizeRel: Turn on optimizations and favor higher space saving   optimizations over higher performance.</li> </ul> <p>Note that <code>Release</code> and <code>MinSizeRel</code> build types both usually produce binaries faster and smaller than <code>RelWithDebInfo</code> and thus should definitely be used in production.</p> <p>When this completes you should have some applications in the <code>build/lpc4078/MinSizeRel/</code> with names such as <code>uart.elf</code> or <code>blinker.elf</code>.</p> <p>Error</p> <p>You can get this error if the arm gnu toolchain wasn't installed correctly and the cmake toolchain was already generated.</p> <pre><code>  The CMAKE_CXX_COMPILER:\n\n    /Users/kammce/.conan2/p/b/arm-ged7418b49387e/p/bin/bin/arm-none-eabi-g++\n\n  is not a full path to an existing compiler tool.\n</code></pre> <p>Fix this by deleting the <code>build/</code> in the <code>demo</code> directory like so:</p> <pre><code>rm -r demos/build\n</code></pre>"},{"location":"getting_started/#uploading-demos-to-device","title":"\ud83d\udcbe Uploading Demos to Device","text":"<p>In order to complete this tutorial you'll one of these devices:</p> <ul> <li>LPC4078 MicroMod with SparkFun ATP board</li> <li>SJ2 Board</li> <li>STM32F103 MicroMod with SparkFun ATP board</li> <li>STM32 Blue Pill along with USB to serial adapter</li> </ul> <p>Question</p> <p>Don't know which serial port to use? Use this guide Find Arduino Port on Windows, Mac, and Linux from the MATLAB docs to help. Simply ignore that its made for Arduino, this guide will work for any serial USB device.</p> LPC4078STM32F103 <p>Install the <code>nxpprog</code> flashing software for LPC devices:</p> <pre><code>python3 -m pip install nxpprog\n</code></pre> <p>Tip</p> <p>On Ubuntu 22.04 you will need to use the command <code>python3.10</code> because the default python is usually 3.8.</p> <pre><code>python3.10 -m pip install nxpprog\n</code></pre> <pre><code>nxpprog --control --binary \"build/lpc4078/MinSizeRel/uart.elf.bin\" --device \"/dev/tty.usbserial-140\"\n</code></pre> <ul> <li>Replace <code>/dev/tty.usbserial-140</code> with the correct port.</li> <li>Replace <code>uart.elf.bin</code> with any other application found in the   <code>demos/applications/</code> directory.</li> </ul> <p>Install the <code>stm32loader</code> flashing software for STM32 devices:</p> <pre><code>python3 -m pip install stm32loader\n</code></pre> <p>then</p> <pre><code>stm32loader -p /dev/tty.usbserial-10 -e -w -v demos/build/stm32f103c8/Debug/blinker.elf.bin\n</code></pre> <p>Replace <code>/dev/tty.usbserial-10</code> with the correct port.</p> <p>Use <code>demos/build/stm32f103c8/Debug/blinker.elf.bin</code> or replace it with any other application to be uploaded.</p>"},{"location":"getting_started/#creating-a-new-project","title":"\ud83c\udf89 Creating a new Project","text":"<p>Start by cloning <code>libhal-starter</code>:</p> <pre><code>git clone https://github.com/libhal/libhal-starter.git\n</code></pre> <p>Take a look at the <code>README.md</code> of libhal/libhal-starter to get details about how to modify the starter project and make it work for your needs.</p>"},{"location":"summary/","title":"Summary","text":"<ul> <li>\ud83c\udfe1 Home</li> <li>\ud83d\ude80 Getting Started</li> <li>\ud83d\udcd6 User Guide</li> <li>\ud83e\uddf1 Fundamentals of libhal</li> <li>\ud83d\udd17 Interfaces in Software Development and libhal</li> <li>\ud83c\udfaf Debugging Code with PyOCD</li> <li>\ud83c\udf9a\ufe0f Configuration</li> <li>\ud83e\udea4 Error Handling in libhal using Boost.LEAF</li> <li>\u2696\ufe0f Policies &amp; FAQ</li> <li>\ud83d\udcda Contributor Guides</li> <li>\ud83d\udcdc Design Philosophy</li> <li>\ud83d\uddc3\ufe0f Organization</li> <li>\ud83c\udfa8 Style Guide</li> <li>\ud83d\udd39 Library Development Guide</li> <li>\ud83d\udcbb VSCode Setup</li> <li>\ud83c\udfd7\ufe0f Architectural Design Decisions</li> <li>\ud83d\udcca Project Information</li> <li>\ud83d\udfe2 Library Status \ud83d\udd34</li> <li>About</li> <li>\ud83e\udde9 APIs</li> </ul>"},{"location":"contributor_guide/architecture/","title":"\ud83c\udfd7\ufe0f Architectural Design Decisions","text":""},{"location":"contributor_guide/architecture/#a1-always-use-modern-c","title":"A.1 Always use modern C++","text":"<p>libhal uses the modern C++. Meaning that libhal is will follow the most modern and available compilers available. When a sufficient number of features have become available in both GCC &amp; Clang and are determined to be useful to libhal libhal will increment its major number to indicate that it has upgraded compiler versions.</p> <p>This decision exists to escape the issues of vendor and toolchain lock in thats prevalant in the C++ and embedded industry. With sufficient testing, upgrading compilers shouldn't result in bugs in applications.</p>"},{"location":"contributor_guide/architecture/#a2-interface-design-choices","title":"A.2 Interface Design Choices","text":"<p>Interfaces MUST follow this layout:</p> <ul> <li>Use <code>#pragma once</code> at the start of the file: Simpler than an include guard</li> <li>All <code>virtual</code> functions must be private &amp; each <code>virtual</code> functions is   accompanied by a public API that is used to call the virtual API</li> <li>The return type of each API MUST be a <code>result&lt;T&gt;</code> where <code>T</code> is a structure.</li> </ul> <p>Pragma once is needed to ensure files are included once. Its also less error prone then hand writing include guards.</p> <p>The reasons for a private virtual with public API can be found in this article.</p> <p>Returning a structure for each API means that, in the future, if the return type needs to be extended, it can be done without breaking down stream libraries. For example:</p> <pre><code>class adc {\n  struct read_t { // V1\n    float percentage;\n  };\n  struct read_t { // V2\n    float percentage;\n    // Optional field that is default initialized to std::nullopt indicating\n    // that it defaults to not exist\n    std::optional&lt;uint8_t&gt; bit_resolution = std::nullopt;\n  };\n};\n</code></pre> <p>Given that the field <code>bit_resolution</code> is an optional, code looking for it can determine if it is available or not, and code that never used it can ignore it.</p>"},{"location":"contributor_guide/architecture/#a21-no-utility-methods-in-interfaces-ufcs","title":"A.2.1 No utility methods in interfaces (UFCS)","text":"<p>Utility functions shall not exist in interface definitions. For example, <code>hal::i2c</code> could have a <code>hal::i2c::write()</code> and <code>hal::i2c::read()</code> function implemented in its interface.</p> <p>This has the effect of reducing the number of headers in the interface files and dependencies. This, in turn, results in an interface that is minimal, clean, and simple.</p> <p>The major purpose of this is to keep compile times down as much possible for each interface. This also ensures that the \"pay-for-what-you-use\" model is followed. No need to pay for a utility you never planned to use.</p> <p>The final reason is in preparation for UFCS (Unified Function Call Syntax). UFCS is a proposal for C++23 and C++26. It did not get into C++23 but is slated for review in 26. For more details see this page What is unified function call syntax anyway?.</p>"},{"location":"contributor_guide/architecture/#a3-using-tweak-files-over-macros","title":"A.3 Using tweak files over macros","text":"<p>Tweak files were used as an alternative to MACROS. MACROs can be quite problematic in many situations and are advised against in the core C++ guidelines. The benefits of tweak files can be found here.</p>"},{"location":"contributor_guide/architecture/#a4-header-only-implementations-see-amendment-a21","title":"A.4 \u274c Header Only Implementations \u27a1\ufe0f (See Amendment A.21)","text":"<p>libhal libraries and drivers are, in general, header-only. libhal uses header only implementations in order to enable the broadest set of package managers, build system and projects to use it.</p> <p>The strongest reason for a header-only approach is due to the fact that libhal libraries never intend to be distributed in prebuilt binaries. Conan is designed to ship with prebuilt binaries or build against the host machine. These settings can be altered, but you still end up with a single global prebuilt binary for a driver does not make sense when that driver could be used in a variety of environments such as the host device for host side tests, a specific target device, and a target device that is in the family of that specific target device.</p> <p>For example, lets consider liblpc40xx. If you are building to target the lpc4078 chip then that prebuilt ought to be built with usage of FPU registers enabled. But if you use that same prebuilt with the lpc4074, you'll find that the program crashes because the 74 variant does not have an FPU. You can attempt make a prebuilt binary for ever possible build variation that an embedded engineer may want, but you'll always come up short. The better approach is to simply build the library each time, thus ensuring that the build flags are considered each time.</p> <p>If compile-times are a concern, there are reasonably easy methods for managing this. See Handling Long Compile Times.</p>"},{"location":"contributor_guide/architecture/#a5-encapsulated-memory-mapped-classes","title":"A.5 Encapsulated Memory Mapped Classes","text":"<p>Target drivers that use Memory-Mapped-IO usually come with a vendor generated header file that describes each peripheral as a structure type, along with bit mask MACROs, and MACROs that result in pointers to each peripheral in memory. The main problem using these headers files causes is naming conflicts. Many of these vendor generated headers work with both C and C++. Meaning that namespaces are not utilized. And many do not expect that they will be used in an environment where another vendor generated header file will exists. So no care is taken to ensure that the names of the types are unique. This WILL cause linker errors as the linker sees both <code>GPIO_TypeDef</code> from an STM library and <code>GPIO_TypeDef</code> from an LPC library that aren't the same.</p> <p>Because of this we have style S.x Encapsulated Memory Mapped classes guideline.</p>"},{"location":"contributor_guide/architecture/#a6-using-halfunction_ref-over-stdfunction","title":"A.6 Using hal::function_ref over std::function","text":"<p><code>std::function</code> has all of the flexibility and functionality needed, but it has the potential to allocate and requires potentially expensive copy operations when passed by value.</p> <p><code>hal::function_ref</code> is a non-owning version of the <code>std::function</code>, with a size of just two pointers. <code>hal::function_ref</code> fits most use cases in that class functions that take them only need them for the duration of the function and do not need to own them for later.</p> <p>!!! info <code>hal::function_ref</code> is an alias for <code>tl:function_ref</code> which comes from     the project     TartanLlama/function_ref.</p>"},{"location":"contributor_guide/architecture/#a7-using-virtual-runtime-polymorphism","title":"A.7 Using <code>virtual</code> (runtime) polymorphism","text":"<p>Polymorphism is critical for libhal to reach the goals of flexible and easy of use. Static based polymorphism, by its nature, is inflexible at runtime and can be quite complicated to work with.</p> <p>Runtime polymorphism, or the usage of <code>virtual</code> enables a broader scope of flexibility and isolation between drivers and application logic. The only downside to using <code>virtual</code> polymorphism is the cost of a virtual function call. But the actual cost of making a virtual function call is usually tiny in comparison to the work performed in the actual API call. In most cases the call latency and lack of inlining of a virtual call isn't an important factor in most applications.</p> <p>And over all, along with the broad amount of flexibility comes the ease of use. Virtual polymorphism for interfaces is very easy to perform and has a ton of language support.</p>"},{"location":"contributor_guide/architecture/#a8-strongly-leverage-package-managers","title":"A.8 Strongly Leverage Package Managers","text":"<p>Finding and integration libraries into C++ programs is a pain. Doing the same thing for embedded is doubly so, especially if there is vendor IDE lock in. libhal seeks to escape this by using the available package managers and indexes.</p> <p>Libhal was designed around and split up into parts that each come together via these package managers. The purpose of this design is to achieve:</p> <ul> <li>Stable version and release control for each library</li> <li>Can be easily found the indexes</li> <li>Ease of integration</li> </ul>"},{"location":"contributor_guide/architecture/#a9-foundation-interface-stability","title":"A.9 Foundation &amp; Interface Stability","text":"<p><code>libhal-util</code>, <code>libhal-mock</code> and <code>libhal-soft</code> were all apart of <code>libhal</code> originally, but due to the constant changes and API breaks in those categories of code, the version number of <code>libhal</code> would increment constantly, shifting the foundation of the ecosystem. To prevent constant churn and API breaks <code>libahl</code> was split into those 4 libraries.</p> <p>The goal is to keep the version number for <code>libhal</code> constant for long periods of time to prevent breaking down stream libraries, drivers, and applications.</p>"},{"location":"contributor_guide/architecture/#a10-libhal-driver-directory","title":"A.10 libhal driver directory","text":"<p>One of the libhal repos will contain a directory of libhal libraries that extend it along with which interfaces it implements and what type of library it is.</p> <p>Official libhal libraries must go into the directory. Developers outside of the libhal organization can also contribute to and opt into this directory by making a PR to the repo containing the directory.</p> <p>The purpose of this is to make finding and exploring the available set of drivers easier for the end developer by having them all in one place.</p>"},{"location":"contributor_guide/architecture/#a11-github-actions-remote-workflows","title":"A.11 Github Actions &amp; Remote Workflows","text":"<p>libhal uses github and github action \"workflow_dispatch\" to allow other repos to reuse libhal's continuous integration steps. The actions are configurable via input parameters to allow libraries to customize and control how the CI works.</p> <p>libhal's CI attempts to use as many tools as reasonable to make sure that the C++ source code follows the style guide, C++ core guidelines and retains a certain level of quality. All offical libhal libaries must opt in to the common libhal/libhal workflow.</p> <p>This helps to ensure that all projects are held to the same standard and quality. The workflow files can be found in <code>libhal/libhal/.github/workflows</code>.</p>"},{"location":"contributor_guide/architecture/#a12-boostut-as-our-unit-testing-framework","title":"A.12 Boost.UT as our unit testing framework","text":"<p>Boost.UT was chosen for its lack of macros, stunning compile time performance, and its ease of use.</p>"},{"location":"contributor_guide/architecture/#a13-boostleaf-for-error-handling","title":"A.13 Boost.LEAF for error handling","text":"<p>One major issue with any project is handling errors. Because the <code>libhal</code> interfaces can be used in such broad environments, it is hard to determine what the BEST error type in advance could work for all users. Some use error codes, some use <code>std::expected&lt;T, E&gt;</code>, and some use exceptions.</p> <p>Error codes are problematic as they tend to lack details and context around an error. Sometimes the documentation along with the error code provides all of the necessary context, but many times more context is needed.</p> <p><code>std::expected&lt;T, E&gt;</code> seems like a better alternative to error codes, but... is it really? What should <code>E</code> be? An error code? What if we have it be an error code and a const string. What if we want a file name and function name? What about a line number? What about 16 bytes for holding context information about the error? That should be enough, right? What about- what about- what about? ... wait, how big is this error type? 32 bytes? Wasn't this supposed to be light weight? Unfortunately, <code>std::expected</code> is not a good choice for interfaces with extremely broad and unknowable of error states. This forces the error type to be massive to accommodate everything and everyone.</p> <p>Exceptions somewhat fix this issue but are still lacking. The benefit of exceptions is that you can throw just about anything, meaning the developer can provide loads of information in the thrown object. But exceptions fail on 4 counts:</p> <ul> <li>Exceptions tend to not be available for embedded systems, either due to a     toolchain not compiling with them enabled or because a project has strict     requirements that forbid exceptions.</li> <li>When exceptions do occur, the amount of time it takes to reach its catch can     take a long time, longer than what real time applications can handle.</li> <li>Normally requires heap allocation</li> <li>Exceptions can only throw one type and the cost of those thrown exceptions     are always paid for.</li> </ul> <p>Boost.LEAF has the following properties:</p> <ul> <li>Portable single-header format, no dependencies.</li> <li>Tiny code size when configured for embedded development.</li> <li>No dynamic memory allocations, even with very large payloads.</li> <li>Deterministic unbiased efficiency on the \"happy\" path and the \"sad\" path.</li> <li>Error objects are handled in constant time, independent of call stack depth.</li> <li>Can be used with or without exception handling.</li> <li>Can throw more than 1 error at a time</li> </ul> <p>All of these features are critical for libhal to have the performance for real time applications.</p> <p>The last feature is important for debugging, bug reports, and context specific error handling. Boost.LEAF gives the driver the choice to emit several error types and allows the user to pick out which one they would like to opt to catch if any of them. This can be used to capture an error code as well as s snapshot of the register map of a peripheral, the object's current state or even a debug message.</p>"},{"location":"contributor_guide/architecture/#a14-using-statement-expressions-with-hal_check","title":"A.14 Using Statement Expressions with <code>HAL_CHECK()</code>","text":"<p><code>HAL_CHECK()</code> is the only MACRO in <code>libhal</code>. It exists because there is nothing like Rust's <code>?</code> operator which either unwraps a value or returns an error from the current function. The \"Statement Expression\" only works with GCC &amp; Clang which is one of the reasons why <code>libhal</code> only supports those compilers. Compare the following two expressions:</p> <pre><code>// 1. Using statement expressions\nauto percentage = HAL_CHECK(adc.read()).percentage;\n\n// 2. Without using statement expressions\nHAL_CHECK(adc_read_temporary, adc.read());\nauto percentage = adc_read_temporary.percentage;\n</code></pre> <p>The second option looks very unnatural and require explanation. On the other hand users who have never seen <code>HAL_CHECK()</code> in action have an immediate idea of how it works in the first section of the code. Portability to other compilers was sacrificed in order to make the code easier to read, understand, and write.</p>"},{"location":"contributor_guide/architecture/#a15-libhal-will-not-use-fixed-point","title":"A.15 <code>libhal</code> WILL NOT use fixed point","text":"<p>Because fixed point will NOT result in better performance or space savings compared to SOFTWARE floating point. Team did venture to use fixed point throughout the entire code base and when we felt that the fixed point code reached a point where it was usable everywhere, we benchmarked it and got these:</p> <pre><code>double_time            = 8921794\n[i64 +Round]fixed_time = 4558238 (best fixed point option)\n[soft]float_time       = 1424913\n[i64 -Round]fixed_time = 1410720 (precision issues)\n[i32 +Round]fixed_time = 815107  (will easily overflow)\n[hard]float_time       = 110089  (not always available)\n[i32 -Round]fixed_time = 95085   (will not actually work)\n</code></pre> <p>Here is an old gist of the example: kammce/fixed_v_float.cpp</p> <p>The above metrics were for a program that run a map function to map an input number from one range to another range. The numbers on the right hand side are the number of cycles of a Arm Cortex M4F DWT counter. Fixed point 32-bit integers is enough for a representation but to handle arithmetic like multiplication, 64-bit integers were needed. Those 64-bit operations resulted in computation time approaching double floating point. If a system used 32-bit floats, the 32-bit fixed point would be ~4x slower. If a system used double floating point in software mode, it will only be ~2x slower than 32-bit fixed point. Fixed point, over all, is more expensive in terms of space and time.</p> <p>If you don't believe the metrics measured here, you can also check fpm performance metrics. Notice how fpm fairs far worse for anything that isn't addition/subtraction.</p> <p>See these articles for more details:</p> <ul> <li>You're Going To Have To   Think!</li> <li>WHY FIXED POINT WON'T CURE YOUR FLOATING POINT   BLUES</li> <li>WHY RATIONALS WON\u2019T CURE YOUR FLOATING POINT   BLUES</li> <li>Why Computer Algebra Won\u2019t Cure Your Floating Point   Blues</li> <li>Why Interval Arithmetic Won\u2019t Cure Your Floating Point   Blues</li> </ul>"},{"location":"contributor_guide/architecture/#a16-libhal-does-not-use-a-units-library","title":"A.16 <code>libhal</code> does NOT use a units library","text":"<p>Unit libraries have the potential to really help prevent an entire category of unit based errors, it is also extremely difficult and annoying to use.</p> <p>Th article Unit of measurement libraries, their popularity and suitability goes into detail about the usability issues faced by unit libraries. Because, at the time of writing <code>libhal</code> there is not a unit library that is easy to use and concise, <code>libhal</code> decided to simply stick with 32-bit floats and helper UDLs.</p>"},{"location":"contributor_guide/architecture/#a17-always-return-halresultt-from-every-api","title":"A.17 Always return <code>hal::result&lt;T&gt;</code> from every API","text":"<p>Every interface in libhal returns a <code>hal::result&lt;T&gt;</code> type.</p> <p>The return types should be a <code>result&lt;T&gt;</code> because the implementation could be an abstraction for anything. As an example, it could come from an I2C to PWM generator and if something goes wrong with the i2c communication, the information must be emitted from the function.</p>"},{"location":"contributor_guide/architecture/#a18-using-inplace_functionhalcallback-for-interrupt-callbacks","title":"A.18 Using <code>inplace_function</code>/<code>hal::callback</code> for interrupt callbacks","text":"<p>There are interfaces such as <code>hal::can</code>, <code>hal::interrupt_pin</code>, and <code>hal::timer</code> that all have APIs for setting a callback.</p> <p>Because those callbacks could be lambdas, function objects, pure functions, or other callable types, we need a polymorphic type erased function type that can take any callable type as input and call it when its <code>operator()</code> is called.</p> <p>The options for these callbacks are:</p> <ul> <li><code>std::function</code><ul> <li>PROS<ul> <li>Part of the standard library</li> <li>Can take any callable type without restrictions</li> </ul> </li> <li>CONS<ul> <li>Allocating (compiler implementations will use SBO but the size of   those buffers are not specified in the standard and should not be   relied upon)</li> <li>Can be quite large in size (40 bytes on 32-bit arm)</li> </ul> </li> </ul> </li> <li><code>function_ref</code><ul> <li>PROS<ul> <li>Very lightweight (very fast construction)</li> <li>Very small size (2 pointers in size)</li> </ul> </li> <li>CONS<ul> <li>For this to work as a callback, the callable passed to the   <code>function_ref</code> must have a lifetime that is greater than the object   implementing the interface.</li> </ul> </li> </ul> </li> <li><code>inplace_function</code><ul> <li>PROS<ul> <li>Works and behaves just like <code>std::function</code></li> </ul> </li> <li>CONS<ul> <li>Fixed callable size limit</li> </ul> </li> </ul> </li> </ul> <p><code>std::function</code> is automatically out because it is allocating. Using <code>std::function</code> for any interface API would ensure that applications that disallow dynamic allocations after boot or in general could never use them.</p> <p><code>function_ref</code> has two great PROS but the largets CON is lifetime issues that are really easy to fall into. Specifically something like this:</p> <pre><code>obj.on_event([&amp;single_capture]() {\n  // does a thing  ...\n});\n</code></pre> <p>The lambda is actually a temporary! So after this call it is out of scope and no longer exists. If the reference to temporary is stored and called later, the code WILL suffer from a \"stack use after scope\" violation which is undefined behavior.</p> <p><code>inplace_function</code> has all of the features of <code>std::function</code> but with limited size. Due to this, constructing an <code>inplace_function</code> is deterministic and relatively light weight.</p>"},{"location":"contributor_guide/architecture/#a19-halcallback-sizing","title":"A.19 <code>hal::callback</code> sizing","text":"<p><code>hal::callback</code> is an alias to <code>inplace_function</code> with a buffer size of 2 pointers (<code>sizeof(std::intptr_t) * 2</code>). This size was chosen in order to be small and easily storable. Two pointers worth of size should be enough to hold a pointer to <code>this</code> in classes as well a pointer to some sort of state object.</p> <p>The size of the callback object was not choosen in order to improve the performance of calling callback setting class functions. Even with the small size of <code>hal::callback</code>, its too large to take advantage of register based parameter passing. Thus the size of 2 pointers was mostly to help in keeping the memory footprint of the <code>callback</code> small. In most cases, setting an callback is something that is either done once or done very infrequently, and thus does not get much of a benefit from higher performance function calls.</p>"},{"location":"contributor_guide/architecture/#a20-why-functions-that-setup-events-do-not-return-halstatus","title":"A.20 Why functions that setup events do not return <code>hal::status</code>","text":"<p>Functions like <code>hal::can::on_receive()</code> and <code>hal::interrupt_pin::on_trigger()</code> return void and not <code>hal::status</code> like other APIs. Thus these functions cannot return an error and are considered \"infallible\". There infallibility guarantee makes constructing drivers using these interfaces easier. It also eliminates the need for drivers to concern themselves with handling errors from these APIs.</p> <p>This guarantee is easily made, because having any one of these APIs fail IS A bug and not something that a developer should or could be responsible with handling. These APIs MUST be implemented as target library peripheral drivers because setting interrupts is something that only target and processor libraries can do. Setting up and configuring interrupts is only possible if the processor supports it. Being apart of a target library means that they know exactly the set of possible configurations that are allowed. This also means that constructing a target peripheral with interrupt customization can be include compile time checks as well.</p>"},{"location":"contributor_guide/architecture/#a21-critical-importance-of-providing-prebuilt-binaries","title":"A.21 Critical importance of providing prebuilt binaries","text":"<p>This amends architectural component A.4 and pivots away from header only libraries over to prebuilt binaries.</p> <p>The following are the reasons why supporting, producing and distibuting prebuilt binaries is critical to libhal.</p> <ul> <li>\u23f1\ufe0f Faster compilation times: When a project grows in size, compiling   a C++ codebase can become time-consuming. By using precompiled binaries,   the compiler has less work to do because portions of the code have already   been compiled. It doesn't need to parse and compile the same headers over and   over again. Developers will refuse to use libhal if it results in extremely   long compilation times. They will tire of the project and seek faster to   compile alternatives.</li> <li>\u2705 Consistency: With precompiled binaries, you can be sure that the same   code will be compiled in the same way, which can reduce inconsistencies   between different environments or build configurations. libhal will not be   taken seriously if libhal didn't use prebuilt binaries and also support   producing them. Distributing consistent code in a consistent form will be a   requirement for many organizations seeking to use libhal.</li> <li>\ud83d\udce6 Code distribution and updates: When distributing C++ code, rather than   give out the full source code or require users to compile it themselves,   providing a precompiled binary is more user-friendly. Updates to the program   can also be handled by replacing the old binaries with the new ones, without   requiring the end-user to handle the compilation process. The philosophy of   conan regarding library packages is that, at their core, C++ libraries are   header files and prebuilt binaries.</li> <li>\ud83d\udd12 Protection of Intellectual Property: Precompiled binaries are much   harder to reverse-engineer than raw source code. If a developer wants to   write an application and distribute the binary, but the C++ code contains   proprietary algorithms or trade secrets that you don't want to expose to the   public, distributing it as a precompiled binary can provide an additional   layer of protection.</li> </ul> <p>In order to provide the best experience for our developers as well as necessary features of the platform, libhal emphasizes prebuilt libraries over header only.</p> <p>Note</p> <p>Why the sudden change from A.4 to this? Supporting header-only made bringing up libhal much easier. The process of implementing prebuilt binaries required adding additional architecture settings, required the use of conan profiles to make the arm-gnu-toolchain available globally for all packages, figuring out how to insert architectural compiler flags and ensure they propogate to all packages took time and was a complex process. And header-only libraries allowed the initial version of libhal to bypass all of this.</p>"},{"location":"contributor_guide/arm_cortex_bring_up/","title":"\ud83d\udd38 Bare-Metal ARM Cortex Target Bring-Up","text":"<p>Info</p> <p>TO BE MOVED TO <code>libhal-armcortex</code> REPO</p> <p>This guide will step you through making a libhal + conan target library for a arm processor microcontroller. Unlike libhal applications that can be executed on a machine running an OS like linux, example Raspberry Pi and Beagle Boards, you cannot just execute the binary.</p> <p>This guide assumes that <code>libhal-library</code> was used as a template and has already updated and changed all of the names from <code>libhal-library</code> to the appropriate library name.</p> <p>In order to build an application that can be loaded and executed onto a microcontroller you only need:</p> <ol> <li>Add <code>libhal-armcortex</code> as a dependency</li> <li>Provide a linker script for each microcontroller</li> <li>Determine minimum compiler flags for each microcontroller</li> <li>Provide a library component for that microcontroller</li> </ol> <p>The rest can be handled by the <code>arm-gnu-embedded-toolchain</code>'s <code>crt0</code> implementation, the <code>arm-gnu-embedded-toolchain</code> conan package and the <code>libhal-armcortex</code> conan package.</p>"},{"location":"contributor_guide/arm_cortex_bring_up/#adding-the-libhal-armcortex-dependency","title":"Adding the <code>libhal-armcortex</code> dependency","text":"<p>Simply add <code>libhal-armcortex</code> to your <code>requirements()</code> method:</p> <pre><code>def requirements(self):\n    # ...\n    self.requires(\"libhal-armcortex/[^1.0.1]\")\n</code></pre>"},{"location":"contributor_guide/arm_cortex_bring_up/#writing-the-linker-scripts","title":"Writing the linker scripts","text":""},{"location":"contributor_guide/arm_cortex_bring_up/#setup-linker-script-directory","title":"Setup linker script directory","text":"<p>Create a <code>linker_scripts</code> directory at the root of the library package. Add <code>linker_scripts/*</code> directory to the export sources in the package <code>conanfile.py</code>, like so:</p> <pre><code>exports_sources = \"include/*\", \"linker_scripts/*\", \"tests/*\", \"LICENSE\"\n</code></pre>"},{"location":"contributor_guide/arm_cortex_bring_up/#finding-linker-scripts-info","title":"Finding linker scripts info","text":"<p>Lets consider the <code>lpc4074</code> microcontroller. What you'll need to figure out is:</p> <ol> <li>Flash memory address &amp; size</li> <li>Ram memory address &amp; size</li> </ol> <p>These sections are part of whats called the \"memory map\". Most modern day systems use a system called \"Memory-mapped I/O\" which means that the system uses the same address space to address both memory and I/O devices. In this case we simply want to find the addresses of the flash memory and ram memory. This information can be found in the data sheet or user manual of the chip.</p> <p>The LPC40 series of microcontrollers will be used for this example: The memory map can be found on page 52 of the <code>LPC408X_7X.pdf</code> data sheet or page 14 of the <code>UM10562.pdf</code> user manual.</p> <p></p> <p> Figure 1. LPC40xx Memory Map </p> <p>Here you can see that flash starts at address <code>0x00000000</code> for all sizes of flash memory. The SRAM locations all start at <code>0x10000000</code> for all sizes of SRAM. This chart does not provide which chips have which ram and flash sizes.</p> <p>Looking through the data sheet and searching for terms like \"part numbers\", \"ordering options\", or even just the number 512 (the maximum flash size), eventually this section will appear:</p> <p></p> <p> Figure 2. LPC40xx Part Ordering Info part 1 </p> <p></p> <p> Figure 3. LPC40xx Part Ordering Info part 2 </p> <p>Now all of the information to write the linker scripts is available:</p> lpc4072.ldlpc4074.ldlpc4076.ldlpc4078.ldlpc4088.ld <pre><code>__flash = 0x00000000;\n__flash_size = 64K;\n__ram = 0x10000000;\n__ram_size = 16K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre> <pre><code>__flash = 0x00000000;\n__flash_size = 128K;\n__ram = 0x10000000;\n__ram_size = 32K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre> <pre><code>__flash = 0x00000000;\n__flash_size = 256K;\n__ram = 0x10000000;\n__ram_size = 64K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre> <pre><code>__flash = 0x00000000;\n__flash_size = 512K;\n__ram = 0x10000000;\n__ram_size = 64K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre> <pre><code>__flash = 0x00000000;\n__flash_size = 512K;\n__ram = 0x10000000;\n__ram_size = 64K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre> <p>Question</p> <p>You may be wondering why the RAM size is 64kB and not 96kB for some of the linker scripts and thats due to the fact that the LPC40xx series has a dual SRAM architecture. To keep this simple, only the largest RAM block is supported.</p> <p>The linker script only needs 4 lines as <code>libhal-armcortex</code> provides a standard linker script for ARM microcontrollers supporting 1 flash memory and 1 ram device. Defining the <code>__flash</code>, <code>__flash_size</code>, <code>__ram</code>, and <code>__ram_size</code> linker script variables is all that is needed to make a usable linker script.</p> <p>There are plans to support dual flash, dual ram and other varieties of flash and ram combinations in the future in <code>libhal-armcortex</code>.</p> <p>Warning</p> <p>Many of the microcontrollers come in different packages and may have some differences in the number of peripherals they support, pins they have and performance. The linker script does not need to worry about such differences and thus, a linker script should NOT be made for every possible chip variety in the series but for the common flash sizes and ram sizes for each.</p>"},{"location":"contributor_guide/arm_cortex_bring_up/#compiler-flags","title":"Compiler flags","text":""},{"location":"contributor_guide/arm_cortex_bring_up/#processor-flags","title":"Processor flags","text":"<p>The data sheet will include information about the processor. The compiler flag will match the following based on the CPU:</p> <ul> <li><code>-mcpu=cortex-m0</code></li> <li><code>-mcpu=cortex-m0plus</code> (cortex-M0+)</li> <li><code>-mcpu=cortex-m1</code></li> <li><code>-mcpu=cortex-m3</code></li> <li><code>-mcpu=cortex-m4</code></li> <li><code>-mcpu=cortex-m7</code></li> <li><code>-mcpu=cortex-m23</code></li> <li><code>-mcpu=cortex-m33</code></li> <li><code>-mcpu=cortex-m35p</code></li> <li><code>-mcpu=cortex-m55</code></li> <li><code>-mcpu=cortex-m85</code></li> <li><code>-mcpu=cortex-m1.small-multiply</code></li> <li><code>-mcpu=cortex-m0.small-multiply</code></li> <li><code>-mcpu=cortex-m0plus.small-multiply</code></li> </ul>"},{"location":"contributor_guide/arm_cortex_bring_up/#floating-point-support","title":"Floating Point Support","text":"<p>After one of the following to the architecture flags:</p> <ul> <li><code>-mfloat-abi=soft</code>: if the processor is an cortex-m3 or below</li> <li><code>-mfloat-abi=softfp</code>: if the processor is a cortex-m4 and above AND also has   a floating point unit. This can be determined by searching the data sheet.</li> </ul>"},{"location":"contributor_guide/arm_cortex_bring_up/#creating-components-for-the-library","title":"Creating components for the library","text":"<p>libhal target library's split up the library into components, one for each microcontroller variant. For LPC40 that split would look like: <code>libhal::lpc4072</code>, <code>libhal::lpc4074</code>, <code>libhal::lpc4076</code>, <code>libhal::lpc4078</code>, and <code>libhal::lpc4088</code>. When a build system, for example, uses the <code>libhal::lpc4078</code> component, it includes the necessary compiler flags and linker script selection.</p> <p>Along with these components, will be a special generic component named <code>libhal::lpc</code> which does not provide any compiler flags or linker script. This special target is used for applications that want to use their own linker script, or for software running on a host machine like simulations or unit tests.</p> <p>To add components it must be added in the <code>package_info</code> method of the <code>ConanFile</code> package class. Here is what it looks like for the <code>libhal-lpc</code> library. Copy this section and tailor it to your needs.</p> <pre><code>def package_info(self):\n  # Specify, for the component, all requirements of the package\n  requirements_list = [\"libhal::libhal\",\n                       \"libhal-util::libhal-util\",\n                       \"libhal-armcortex::libhal-armcortex\",\n                       \"ring-span-lite::ring-span-lite\"]\n\n  # List of REQUIRED compiler flags for the gnu-arm-embedded-toolchain for some\n  # of the chips. These are determined by the capabilities of the chip.\n  # For example all but the lpc4072 and lpc4074 have hardware floating point\n  # arithmetic support so they ought to use \"float-abi=softfp\" which uses the\n  # floating point hardware BUT is ABI compatible with the software\n  # implementation.\n  m4f_architecture_flags = [\n      \"-mcpu=cortex-m4\",\n      \"-mfloat-abi=softfp\",\n  ]\n\n  # List of REQUIRED compiler flags for the gnu-arm-embedded-toolchain for\n  # some of the chips. These are determined by the capabilities of the chip.\n  # For example the lpc4072 and lpc4074 do not have hardware floating point\n  # arithmetic support so they must use \"float-abi=soft\" for a software\n  # implementation.\n  m4_architecture_flags = [\n      \"-mcpu=cortex-m4\",\n      \"-mfloat-abi=soft\"\n  ]\n\n  # Create a path to the linker_script directory which resides in the\n  # package's package_folder.\n  linker_path = os.path.join(self.package_folder, \"linker_script\")\n\n  # Set the cmake file name\n  self.cpp_info.set_property(\"cmake_file_name\", \"libhal-lpc\")\n  # All the package to be found in anyway with cmake\n  self.cpp_info.set_property(\"cmake_find_mode\", \"both\")\n\n  # Create the special/generic component \"lpc\" and set its component name\n  self.cpp_info.components[\"lpc\"].set_property(\n      \"cmake_target_name\",  \"libhal::lpc\")\n\n  # This is where we add the path to our linker scripts to the set of linker\n  # flags.\n  self.cpp_info.components[\"lpc\"].exelinkflags.append(\"-L\" + linker_path)\n\n  # Add the list of requirements to the generic component\n  self.cpp_info.components[\"lpc\"].requires = requirements_list\n\n  # Helper function for creating components\n  def create_component(self, component, flags):\n\n      link_script = \"-Tlibhal-lpc/\" + component + \".ld\"\n      component_name = \"libhal::\" + component\n      self.cpp_info.components[component].set_property(\n          \"cmake_target_name\", component_name)\n      # Make the special component the only requirement for the component,\n      # inheriting all of the transitive dependencies.\n      self.cpp_info.components[component].requires = [\"lpc\"]\n      # Add the link script and flags to the component's linker flags and\n      # compiler flags\n      self.cpp_info.components[component].exelinkflags.append(link_script)\n      self.cpp_info.components[component].exelinkflags.extend(flags)\n      # Add flags to the cflags &amp; cxxflags to ensure that each compilation unit\n      # Knows the instruction set and float ABI\n      self.cpp_info.components[component].cflags = flags\n      self.cpp_info.components[component].cxxflags = flags\n\n  # Create the components for each chip.\n  create_component(self, \"lpc4072\", m4_architecture_flags)\n  create_component(self, \"lpc4074\", m4_architecture_flags)\n  create_component(self, \"lpc4076\", m4f_architecture_flags)\n  create_component(self, \"lpc4078\", m4f_architecture_flags)\n  create_component(self, \"lpc4088\", m4f_architecture_flags)\n</code></pre>"},{"location":"contributor_guide/arm_cortex_bring_up/#verifying","title":"Verifying","text":""},{"location":"contributor_guide/arm_cortex_bring_up/#creating-the-package","title":"Creating the package","text":"<p>Run <code>conan create .</code> in the folder with the <code>conanfile.py</code> recipe in it. The test package and build stages should show something like this during the cmake phase:</p> <pre><code>-- Conan: Component target declared 'libhal::lpc'\n-- Conan: Component target declared 'libhal::lpc4072'\n-- Conan: Component target declared 'libhal::lpc4074'\n-- Conan: Component target declared 'libhal::lpc4076'\n-- Conan: Component target declared 'libhal::lpc4078'\n-- Conan: Component target declared 'libhal::lpc4088'\n</code></pre>"},{"location":"contributor_guide/arm_cortex_bring_up/#testing-out-a-demo","title":"Testing out a demo","text":"<p>Create a demo and have it require the library. In this case the demo <code>conafile.py</code> may include:</p> <pre><code>from conan import ConanFile\nfrom conan.tools.cmake import CMake, cmake_layout\n\n\nclass Lpc40xxDemos(ConanFile):\n    settings = \"compiler\", \"build_type\"\n    generators = \"CMakeToolchain\", \"CMakeDeps\", \"VirtualBuildEnv\"\n\n    def requirements(self):\n        self.requires(\"libhal-lpc/1.1.4\") # &lt;-- change this\n        self.requires(\"libhal-util/[^1.0.0]\") # &lt;-- update this if necessary\n        self.tool_requires(\"gnu-arm-embedded-toolchain/11.3.0\")\n        self.tool_requires(\"cmake-arm-embedded/0.1.1\")\n\n    def layout(self):\n        cmake_layout(self)\n\n    def build(self):\n        cmake = CMake(self)\n        cmake.configure()\n        cmake.build()\n</code></pre> <p>Change the library name to the library you are creating.</p> <pre><code>self.tool_requires(\"gnu-arm-embedded-toolchain/11.3.0\")\nself.tool_requires(\"cmake-arm-embedded/0.1.1\")\n</code></pre> <p>The above two requirements are required to download and install the toolchain/compiler and the cmake toolchain/helper files. The project should compile if everything was done correctly.</p>"},{"location":"contributor_guide/library_guides/","title":"\ud83d\udd39 Library Development Guide","text":"<p>Info</p> <p>Documentation coming soon...</p>"},{"location":"contributor_guide/organization/","title":"\ud83d\uddc3\ufe0f Organization","text":"<p>This section will explain the different parts/repos of libhal organization and ecosystem and how they are organized.</p>"},{"location":"contributor_guide/organization/#target-libraries","title":"Target Libraries","text":"<p>Target libraries depend on processor/OS libraries. The target libraries will include drivers for peripherals contained within their chip packages or, in the case of development boards and SBC (single board computers), these can also contain drivers external to the main chip. Processor/OS libraries contain APIs specific to those platforms for doing such things as handling interrupt service routines, initializing memory and more.</p> <pre><code>flowchart LR\n    libhal\n    subgraph processor/OS\n      libriscvmcu\n      libarmcortex\n      libhal-linux\n    end\n    subgraph arm-targets\n      liblpc40xx\n      libstm32f10x\n    end\n    subgraph riscv-targets\n      libgv32f10x\n      libsifive\n    end\n    subgraph linux-targets\n      libhal-linux-generic\n      libraspi\n    end\n\n    libhal--&gt;libhal-linux\n    libhal--&gt;libriscvmcu\n    libhal--&gt;libarmcortex\n\n    libarmcortex--&gt;liblpc40xx\n    libarmcortex--&gt;libstm32f10x\n\n    libriscvmcu--&gt;libgv32f10x\n    libriscvmcu--&gt;libsifive\n\n    libhal-linux--&gt;libhal-linux-generic\n    libhal-linux--&gt;libraspi</code></pre>"},{"location":"contributor_guide/organization/#device-libraries","title":"Device Libraries","text":"<p>Device driver libraries have a very simple relationship tree. Device libraries just need the libhal interfaces to work. The implementations of those interfaces will come from a target library in the application.</p> <pre><code>flowchart TD\n    libhal\n    libhal--&gt;libhal-soft\n    libhal--&gt;libmpu\n    libhal--&gt;libesp8266\n    libhal--&gt;libdrv\n    libhal--&gt;libwii\n    libhal--&gt;liballegro-micro\n    libhal--&gt;libdisplay-ssd\n    libhal--&gt;libled-apa-sk\n    libhal--&gt;libmatrix</code></pre>"},{"location":"contributor_guide/organization/#typical-application","title":"Typical Application","text":"<p>Lets consider an application such as \"Pong\". A game of pong where we use an LED matrix and two Wii controllers using the STM32F103 microcontroller.</p> <pre><code>flowchart LR\n    libhal--&gt;libmatrix--&gt;app\n    libhal--&gt;libarmcortex--&gt;libstm32f10x --&gt;app\n    libhal--&gt;libwii--&gt;app</code></pre> <p>The <code>conanfile.txt</code> would look something like this:</p> <pre><code>[requires]\nlibstm32f10x/1.1.0\nlibmatrix/1.0.2\nlibwii/1.5.2\n\n[generators]\nCMakeToolchain\nCMakeDeps\nVirtualRunEnv\n</code></pre>"},{"location":"contributor_guide/organization/#application-libraries","title":"Application Libraries","text":"<p>Application libraries are effectively applications with no specific dependency on a particular target. The point of a Application library is to deploy a fully fledged application, but with customizable drivers. For example, the pong game mentioned earlier doesn't require a wii controller or a LED matrix specifically. You could take a <code>hal::display</code> interface (not currently available) and some <code>pong::gamepad</code> interface defined by the Application library that the developer can implement themselves. Then the pong Application can take your display, gamepad and additional information like, \"paddle size\" and \"font size\" and use it to generate a game of pong. The developer gets the opportunity to choose which parts they want for each. Maybe they want a very large TFT display or they want to use a LED matrix. Maybe they want to use a Stadia controller or maybe they want to make a controller out of capacitive sensors and bananas. The choices are endless.</p>"},{"location":"contributor_guide/organization/#finding-drivers","title":"\ud83d\udd0d Finding Drivers","text":"<p>To find drivers you can look in three locations</p> <ul> <li>libhal organization</li> <li>conan center index</li> <li>libhal driver index \u274c</li> </ul> <p>Example</p> <p>libhal driver index is not available currently and is key to finding drivers around the ecosystem.</p> <p>Search for the name of the device or target you are interested with with the prefix <code>lib</code> in front of it. Try not to be too specific though. For example, the <code>stm32f103c8t6</code> microcontroller target library drivers will be in the package <code>libstm32f10x</code>. The <code>mpu6050</code> accelerometer will be in <code>libmpu</code>.</p>"},{"location":"contributor_guide/organization/#reference-material","title":"\ud83d\udcd1 Reference Material","text":"<p>Reference material can be found in the <code>datasheets/</code> and <code>schematic/</code> folders. The layout of these directories match that <code>demos/</code>, where the first layer of folders are named after the microcontroller or board they describe.</p> <p>These folders are updated with relevant documents for easy access for our developers and contributors.</p>"},{"location":"contributor_guide/philosophy/","title":"\ud83d\udcdc Design Philosophy","text":"<p>These are the core design tenets that <code>libhal</code> and libraries extending it must seek to achieve with every design choice, line written, and architecture change made.</p>"},{"location":"contributor_guide/philosophy/#d1-multi-targeted","title":"D.1 Multi Targeted","text":"<p><code>libhal</code> and the libraries that extend it, should work anywhere. So long as the appropriate compiler or cross compiler is used, the driver should do as it is intended. The exception is <code>target</code> libraries which are designated to execute for a particular target. Even so, those <code>target</code> libraries MUST be unit testable on any host machine.</p>"},{"location":"contributor_guide/philosophy/#d2-light-weight","title":"D.2 Light Weight","text":"<p><code>libhal</code> should keep its interfaces and utility code light weight, meaning such things do not allocate, and if they do only once, do not perform long/length copies, unless a copy was the desired operation,</p>"},{"location":"contributor_guide/philosophy/#d3-general","title":"D.3 General","text":"<p><code>libhal</code> interfaces should be general, meaning that they do not include APIs, or configuration settings that are uncommon in most targets or specific to a particular target.</p>"},{"location":"contributor_guide/philosophy/#d4-minimalist","title":"D.4 Minimalist","text":"<p><code>libhal</code> aims to be as simple as possible and no simpler. Interfaces, utility functions, and libraries should be straight forward for most programmers to understand with added complexity only when it is necessary and no other options exist.</p>"},{"location":"contributor_guide/philosophy/#d5-safe-reliable","title":"D.5 Safe &amp; Reliable","text":"<p><code>libhal</code> and its style guide aim to use patterns, techniques, and documentation to help reduce safety issues and improve reliability.</p>"},{"location":"contributor_guide/philosophy/#d6-tested-testable","title":"D.6 Tested &amp; Testable","text":"<p><code>libhal</code> code should be as testable and unit tested.</p>"},{"location":"contributor_guide/philosophy/#d7-compiled-quickly","title":"D.7 Compiled Quickly","text":"<p><code>libhal</code> code should build fast and eliminate/replace any unnecessary dependencies that cause compile times to be long.</p>"},{"location":"contributor_guide/philosophy/#d8-portable","title":"D.8 Portable","text":"<p><code>libhal</code> code should not require or depend on any OS or target specific code or behaviors. <code>libhal</code> is designed to work anywhere and should not rely on OS.</p>"},{"location":"contributor_guide/style/","title":"\ud83c\udfa8 Style Guide","text":""},{"location":"contributor_guide/style/#s0-code-guidelines","title":"S.0 Code Guidelines","text":"<p>All guides follow the C++ Core Guidelines.</p>"},{"location":"contributor_guide/style/#s1-formatting","title":"S.1 Formatting","text":"<ul> <li>Code shall follow libhal's   <code>.clang-format</code>   file, which uses the Mozilla C++ style format as a base with some adjustments.</li> <li>Code shall follow libhal's   <code>.naming.style</code>   file, which is very similar to the standard library naming convention:</li> <li>CamelCase for template parameters.</li> <li>CAP_CASE for MACROs (avoid MACROs in general).</li> <li>lowercase snake_case for everything else.</li> <li>prefix <code>p_</code> for function parameters.</li> <li>prefix <code>m_</code> for private/protected class member.</li> <li>Refrain from variable names with abbreviations where it can be helped. <code>adc</code>,   <code>pwm</code>, and <code>i2c</code> are extremely common so it is fine to leave them as   abbreviations. Most people know the abbreviations more than the words that   make them up. But words like <code>cnt</code> should be <code>count</code> and <code>cdl</code> and <code>cdh</code>   should be written out as <code>clock_divider_low</code> and <code>clock_divider_high</code>.   Registers do get a pass if they directly reflect the names in the data sheet   which will make looking them up easier in the future.</li> <li>Use <code>#pragma once</code> as the include guard for headers.</li> <li>Every file must end with a newline character.</li> <li>Every line in a file must stay within a 80 character limit.</li> <li>Exceptions to this rule are allowed. Use <code>// NOLINT</code> in these cases.</li> <li>Radix for bit manipulation:</li> <li>Only use binary (<code>0b1000'0011</code>) or hex (<code>0x0FF0</code>) for bit manipulation.</li> <li>Never use decimal or octal as this is harder to reason about for most     programmers.</li> <li>Every public API must be documented with the doxygen style comments (CI will   ensure that every public API is documented fully).</li> <li>Include the C++ header version of C headers such as <code>&lt;cstdint&gt;</code> vs   <code>&lt;stdint.h&gt;</code>.</li> </ul>"},{"location":"contributor_guide/style/#s2-refrain-from-performing-manual-bit-manipulation","title":"S.2 Refrain from performing manual bit manipulation","text":"<p>Use <code>hal::bit</code> from <code>libhal-util</code> library to perform bitwise operations operations.</p>"},{"location":"contributor_guide/style/#s3-refrain-from-using-macros","title":"S.3 Refrain from using MACROS","text":"<p>Only use macros if something cannot be done without using them. Usually macros can be replaced with <code>constexpr</code> or const variables or function calls. A case where macros are the only way is for HAL_CHECK() since there is no way to automatically generate the boiler plate for returning if a function returns and error in C++ and thus a macro is needed here to prevent possible mistakes in writing out the boilerplate.</p> <p>Only use preprocessor <code>#if</code> and the like if it is impossible to use <code>if constexpr</code> to achieve the same behavior.</p>"},{"location":"contributor_guide/style/#s4-never-include-c-stream-libraries","title":"S.4 Never include C++ stream libraries","text":"<p>Applications incur an automatic 150kB space penalty for including any of the ostream headers that also statically generate the global <code>std::cout</code> and the like objects. This happens even if the application never uses any part of <code>&lt;iostream&gt;</code> library.</p>"},{"location":"contributor_guide/style/#s5-refrain-from-memory-allocations","title":"S.5 Refrain from memory allocations","text":"<p>Interfaces and drivers should refrain from APIs that force memory allocations or implementations that allocate memory from heap. This means avoiding STL libraries that allocate such as <code>std::string</code> or <code>std::vector</code>.</p> <p>Many embedded system applications, especially the real time ones, do not allow dynamic memory allocations. There are many reasons for this that can be found MISRA C++ and AutoSAR.</p>"},{"location":"contributor_guide/style/#s6-drivers-should-not-log-to-stdout-or-stdin","title":"S.6 Drivers should not log to STDOUT or STDIN","text":"<p>Peripheral drivers must NOT log to stdout or stderr. This means no calls to</p> <ul> <li><code>std::printf</code></li> <li><code>std::cout</code></li> <li><code>std::print</code> (C++26's version of print based on <code>std::format</code>)</li> </ul> <p>Consider using the file I/O libraries in C, C++, python or some other language. Would you, as a developer, ever imagine that opening, reading, writing, or closing a file would (write?) to your console? Especially if there did not exist a way to turn off logging. Most users would be very upset as this would not seem like the role of the file I/O library to spam the console. This gets even worse if a particular application has thousands of files and each operation is logging.</p> <p>The role of logging should be held by the application developer, not their drivers or helper functions, unless the purpose of the helper functions or driver is to write to console.</p>"},{"location":"contributor_guide/style/#s7-drivers-should-not-purposefully-halt-or-terminate-the-application","title":"S.7 Drivers should not purposefully halt OR terminate the application","text":"<p>Drivers are not entitled to halt the execution of the application and thus any code block that would effectively end or halt the execution of the program without giving control back to the application are prohibited.</p> <p>As an example drivers should never call:   - <code>std::abort()</code>   - <code>std::exit()</code>   - <code>std::terminate()</code>   - any of their variants</p> <p>This includes placing an infinite loop block in a driver.</p> <p>An application should have control over how their application ends. A driver should report severe errors to the application and let the application decide the next steps. If a particular operation cannot be executed as intended, then <code>hal::new_error()</code> should be called.</p> <p>Constructors would be the only valid place to put an exit statement, because they cannot return errors only themselves.</p> <p>The solution to this is to use a factory function like so:</p> Device Driver LibraryPeripheral Driver Library <pre><code>class device_driver {\n  public:\n    result&lt;device_driver&gt; create(/* ... */) {\n      // Perform operations that may fail here\n      return device_driver(/* ... */);\n    }\n\n  private:\n    device_driver(/* ... */) {\n      // Constructors should never fail and thus any work done here must not\n      // fail.\n    }\n};\n</code></pre> <pre><code>class peripheral_driver {\n  public:\n    // Since peripherals are constrained and have a finite set of values\n    // This also ensures that the driver is only constructed once and afterwards\n    // simply returns back a reference to that object.\n    template&lt;size_t PortNumber&gt;\n    // NOTE: Returns a reference not an object.\n    //       Objects are owned by the create function\n    result&lt;peripheral_driver&amp;&gt; create(/* ... */) {\n      // Perform operations that may fail here\n      static peripheral_driver driver(/* ... */);\n      return driver;\n    }\n\n  private:\n    peripheral_driver(/* ... */) {\n      // ...\n    }\n};\n</code></pre>"},{"location":"contributor_guide/style/#s8-drivers-should-not-pollute-the-global-namespace","title":"S.8 Drivers should not pollute the global namespace","text":"<p>All drivers must be within the <code>hal</code> namespace or within their own bespoke namespace.</p> <p>Inclusion of a C header file full of register map structures is not allowed as it pollutes the global namespace and tends to result in name collisions.</p> <p>Care should be taken to ensure that the <code>hal</code> namespace is also as clean as possible by placing structures, enums, const data, and any other symbols into the driver's class's namespace like so:</p> <pre><code>namespace hal::target\n{\nclass target {\n  struct register_map {\n    std::uint32_t control1;\n    std::uint32_t control2;\n    std::uint32_t data;\n    std::uint32_t status;\n    // ..\n  };\n\n  struct control1_register {\n    static constexpr auto channel_enable = hal::bit::range::from&lt;0, 7&gt;();\n    static constexpr auto peripheral_enable = hal::bit::range::from&lt;8&gt;();\n    // ...\n  };\n\n  // ...\n};\n}\n</code></pre>"},{"location":"contributor_guide/style/#s9-interface-should-follow-the-public-private-api-scheme","title":"S.9 Interface should follow the public private API Scheme","text":"<p>See private virtual method for more details. Rationale can be found within that link as well.</p>"},{"location":"contributor_guide/style/#s10-avoid-using-bool","title":"S.10 Avoid using <code>bool</code>","text":""},{"location":"contributor_guide/style/#s101-as-an-object-member","title":"S.10.1 As an object member","text":"<p><code>bool</code> has very poor information density and takes up 8-bits per entry. If only one <code>bool</code> is needed, then a bool is a fine object member. If multiple <code>bool</code>s are needed, then use a <code>std::bitset</code> along with static <code>constexpr</code> index positions in order to keep the density down to the lowest amount possible.</p>"},{"location":"contributor_guide/style/#s102-as-a-parameter","title":"S.10.2 As a parameter","text":"<p>See the article \"Clean code: The curse of a boolean parameter\" for details as to why <code>bool</code> parameters are awful.</p> <p><code>bool</code> is fine if it is the only parameter and it acts as a lexical switch, for example:</p> <pre><code>// This is fine because it reads as set \"LED\" voltage \"level\" to \"FALSE\"\nled.level(false);\n// This is fine because it reads as set \"LED\" voltage \"level\" to \"TRUE\"\nled.level(true);\n</code></pre>"},{"location":"contributor_guide/style/#s11-integrating-third-party-libraries-by-source","title":"S.11 Integrating third party libraries by source","text":"<p>In general, third party libraries should NOT be integrated into a library by source. It should be depended upon using a package manager. But in some cases third party libraries must be included by source. In these cases, the third party libraries should be committed into a project, without modifications, into the <code>include/&lt;library_name&gt;/third_party</code> directory. After that commit, the third party libraries can be used by and integrated into the library code base, in a following commit.</p> <p>If a third party library is modified, that library must have a section at the top of the file with the following description:</p> <pre><code>/**\n * [libhal] modifications to this file are as follows:\n *\n *    1. mod 1\n *    2. mod 2\n *    3. mod 3\n *    4. mod 4\n */\n\n/**\n * &lt;LICENSE GOES HERE!&gt;\n */\n</code></pre> <p>Care must be taken to ensure that third party libraries do not conflict with the licenses of libhal libraries and permit direct integration as well as modification.</p> <p>Rationale: Makes keeping track of changes and the history of files easier to manage.</p>"},{"location":"contributor_guide/style/#s12-avoid-stdatomic","title":"S.12 Avoid <code>std::atomic</code>","text":"<p>Avoid using <code>std::atomic</code> because of portability issues across devices in architectures. Especially when <code>std::atomic</code> is not fully supported by the compiler.</p> <p>Info</p> <p><code>target</code> and <code>processor</code> libraries are allowed to use <code>std::atomic</code> if it is available with their cross compiler and toolchain. In this case, the we can know which target devices the software is running on, either the target itself, which we already know can support it, or on a host machine for unit testing, which is very likely to have a compiler that supports atomics.</p>"},{"location":"contributor_guide/style/#s13-avoid-thread","title":"S.13 Avoid <code>&lt;thread&gt;</code>","text":"<p>Embedded system compilers tend to not provide an implementation of <code>&lt;thread&gt;</code> because the choice of which threading model or multi-threading operating system is left to the developer.</p> <p>In general, <code>#include &lt;thread&gt;</code> will almost never work when cross compiling.</p>"},{"location":"contributor_guide/vscode_setup/","title":"\ud83d\udcbb VSCode Setup","text":""},{"location":"contributor_guide/vscode_setup/#add-conan2p-to-includes-path","title":"Add <code>~/.conan2/p</code> to includes path","text":"<p>TDB</p>"},{"location":"contributor_guide/vscode_setup/#setting-the-python-interpreter","title":"Setting the <code>python</code> interpreter","text":"<p>TDB</p>"},{"location":"contributor_guide/vscode_setup/#setting-up-vscode-debugger","title":"Setting up VSCode Debugger","text":"<p>Info</p> <p>Still under investigation...</p>"},{"location":"project_information/about/","title":"About","text":"<p>The world of embedded systems is written almost entirely in C and C++. More and more of the embedded world move away from C and towards C++. This has to do with the many benefits of C++ such as type safety, compile time features, meta-programming, multi-paradigm and much more. When these features are used correctly, they can result in smaller binary sizes and higher performance code than in C.</p> <p>But a problem that embedded C++ software suffers is that there isn't a consistent and common API for embedded libraries. Looking around, you will find that each hardware vendor has their own set of libraries and tools for their specific products. If you write a driver on top of their libraries, you will find that your code will only work for that specific platform/product. In some cases you may also be limited to just their toolchain. You as the developer are locked in to this one specific setup. And if you move to another platform, you must do the work of rewriting all of your code again.</p> <p>libhal seeks to solve this issue by creating a set of generic interfaces for embedded system concepts such as serial communication (UART), analog to digital conversion (ADC), inertial measurement units (IMU), pulse width modulation (PWM) and much more. The advantage of building a system on top of libhal is that higher level drivers can be used with any target platform whether it is a stm32, a nxp micro controller, a RISC-V, or is on an embedded linux.</p> <p>This project is inspired by the work of Rust's embedded_hal and follows many of the same design goals.</p> <p>libhal's design goals:</p> <ol> <li>Serve as a foundation for building an ecosystem of platform agnostic drivers.</li> <li>Must abstract away device specific details like registers and bitmaps.</li> <li>Must be generic across devices such that any platform can be supported.</li> <li>Must be minimal for boosting performance and reducing size costs.</li> <li>Must be composable such that higher level drivers can build on top of these.</li> <li>Be accessible through package mangers so that developers can easily pick and    choose which drivers they want to use.</li> </ol>"},{"location":"project_information/about/#software-copyrights","title":"Software Copyrights","text":"<p>This source code is licensed under the Apache License 2.0 as described in the LICENSE file.</p>"},{"location":"project_information/about/#third-party-library-licenses","title":"Third Party Library Licenses","text":"<ul> <li>Boost.LEAF, BOOST license</li> <li>tl-function-ref/1.0.0, CC0</li> </ul>"},{"location":"project_information/status/","title":"\ud83d\udfe2 Library Status \ud83d\udd34","text":"<p>Repo</p> <p>CI State</p> <p>Coverage</p> <p>Latest Version</p> libhal/libhal-__platform__ libhal/libhal-stm32f1 libhal/libhal-esp8266 libhal/libhal-__device__ libhal/libhal-mpu libhal/libhal-pca libhal/libhal-rmd libhal/libhal-tmp libhal/libhal-mock libhal/libhal-soft libhal/libhal-lpc40 libhal/libhal-util libhal/libhal libhal/libhal-armcortex libhal/libhal-canrouter libhal/libhal-micromod libhal/libhal-mpl libhal/libhal-freertos"},{"location":"user_guide/configuration/","title":"\ud83c\udf9a\ufe0f Configuration","text":""},{"location":"user_guide/configuration/#halon_error_callback","title":"<code>hal::on_error_callback</code>","text":"<p>Libhal provides a simple mechanism for handling calling a function when an error occurs. The error handler is defined as follows:</p> <pre><code>using error_handler = void(void);\ninline error_handler* on_error_callback = nullptr;\n</code></pre> <p>The <code>on_error_callback</code> is a pointer to a function that takes no arguments and returns no value. If this variable is set to something other than <code>nullptr</code>, then the function it points to is called before the error object is returned. <code>hal::new_error()</code> must be used to get this behavior. Calling <code>boost::leaf::new_error</code> will bypass this behavior.</p> <p>This error handler is useful for logging when errors occur. It allows developers to capture information about the state of your program at the time of the error, which can be helpful for debugging.</p> <p>Most importantly, the error handler is very useful for generating a stack trace. A stack trace provides a snapshot of the call stack at a specific point in time. This can be invaluable for understanding the sequence of function calls that led to an error. However, generating a stack trace is only possible at this depth in the call stack, which is why the error handler is so important.</p> <p>To use the error handler, you simply need to define a function that matches the <code>error_handler</code> type, and then assign the address of this function to <code>on_error_callback</code>. Here's an example:</p> <pre><code>void my_error_handler() {\n    // Code to execute when an error occurs\n}\n\nint main() {\n    hal::on_error_callback = &amp;my_error_handler;\n\n    // Rest of your code\n}\n</code></pre> <p>In this example, <code>my_error_handler</code> will be called whenever an error occurs in your code. You can put any code you want in this function to handle the error in a way that makes sense for your application.</p> <p>Note that this pointer is global and care should be taken when modifying it.</p>"},{"location":"user_guide/debugging/","title":"\ud83c\udfaf Debugging Code with PyOCD","text":""},{"location":"user_guide/debugging/#introduction","title":"Introduction","text":"<p>PyOCD is an open-source Python package for programming and debugging Arm Cortex-M microcontrollers using CMSIS-DAP. It's a highly flexible and easy-to-use tool, but it's important to note that it only supports ARM processors.</p> <p>PyOCD stands out for its user-friendly approach compared to other On-Chip Debugging (OCD) tools like OpenOCD, despite being slightly limited in terms of the range of processors it supports.</p> <p>For the full documentation for PyOCD see https://pyocd.io/.</p>"},{"location":"user_guide/debugging/#installation","title":"Installation","text":"<p>To install PyOCD, run the following command in your terminal:</p> <pre><code>python3 -m pip install pyocd\n</code></pre>"},{"location":"user_guide/debugging/#connecting-a-debugger-to-your-device","title":"Connecting a Debugger to your Device","text":"<p>Connect the debugger (STLinkV2) to your MicroMod Carrier board using the STLink to SWD connector adapter. Before connecting and powering everything check that the the ribbon connector is connected to the port with the glowing LED. That is the correct connection. Using the incorrect connection could cause part damage.</p> <p>If you are using another type of device with different connections follow this guide. A connection to ground (<code>GND</code>) must be made between the debugger and the development board in order for the devices to communicate.</p> <p>Danger</p> <p>DOUBLE AND TRIPLE CHECK YOUR CONNECTIONS! Incorrect connects can result in breaking a board, debugger or possible your computer.</p> Connecting SWDConnecting JTAG <p>Connect jumpers from <code>GND</code>, <code>SWDIO</code> and <code>SWDCLK</code> to the pins on the board. If the board supports both <code>SWD</code> and <code>JTAG</code> like many arm cortex boards do, then connect the pins in the following way: <code>SWDIO</code> --&gt; <code>TMS</code> and <code>SWDCLK</code> --&gt; <code>TCK</code>.</p> <p>Connect jumpers from the <code>GND</code>, <code>TDI</code>, <code>TMS</code>, <code>TCK</code>, and <code>TDO</code> pins on the JTAG debugger to the headers on the development board of the same name.</p>"},{"location":"user_guide/debugging/#connecting-to-device-using-pyocd","title":"Connecting to device using PyOCD","text":"<p>The following commands will use <code>pyocd</code> and your debugger to connect to your target platform.</p> lpc40stm32f1 <pre><code>pyocd gdbserver --target=lpc4088 --persist\n</code></pre> <pre><code>pyocd gdbserver --target=stm32f103rc --persist\n</code></pre> <p>To find all of the available platforms use <code>pyocd list --targets</code>.</p>"},{"location":"user_guide/debugging/#using-arm-none-eabi-gdb","title":"Using arm-none-eabi-gdb","text":"<p><code>arm-none-eabi-gdb</code> is a version of GDB (GNU Debugger) configured for debugging Arm Cortex-M devices.</p> <p>To start a GDB debugging session, open an additional terminal or terminal window. Then execute the following command:</p> <pre><code>arm-none-eabi-gdb -ex \"target remote :3333\" -tui path/to/yourfile.elf\n</code></pre> <ul> <li><code>-tui</code>: GDB TUI provides a text window interface for debugging. To start GDB   in TUI mode, use the <code>-tui</code> option</li> <li><code>-ex \"target remote :3333\"</code>: <code>-ex</code> executes a GDB command. And the command   <code>target remote :3333</code> connects to a remote gdb server, in this case, the pyocd   server (with default port <code>:3333</code>).</li> </ul>"},{"location":"user_guide/debugging/#starting-the-debugging-process","title":"Starting the Debugging Process","text":"<p>Here is a cheat sheet for using GDB Cheat Sheet.</p> <p>A typical first breakpoint for a program is to set a breakpoint on main.</p> <pre><code>b main\n</code></pre> <p>Next you will want to reset the program back to the start and halt the CPU using the following command.</p> <pre><code>monitor reset halt\n</code></pre> <p>To begin running through the program use the <code>continue</code> or <code>c</code> command.</p> <pre><code>c\n</code></pre> <p>At this point you should see the source code of your <code>main.cpp</code> show up. Now you can step through your code and set breakpoints using <code>step</code>, <code>next</code>, <code>finish</code> and <code>continue</code>, <code>break</code>, etc.</p> <p>Typically you would use the <code>run</code> command to start the code. When performing firmware testing, the <code>run</code> command is not needed as the code is already \"running\" on the remote microcontroller.</p> <p>Info</p> <p>On boards with a factory bootloader, when you start debugging, you will notice that you cannot see the source code lines in the gdb shell. This is because the bootloader instructions are not associated with any addresses in your code, thus you will not see source code. This is fine. Continue with the guide. The LPC40xx family of microcontrollers has such a bootloader.</p>"},{"location":"user_guide/debugging/#stepping-through-code","title":"Stepping Through Code","text":"<p>Once in a GDB session, you can step through your code using the following commands:</p> <ul> <li><code>next</code> or <code>n</code>: Executes the next line in the source code. If the line contains   a function call, it treats the entire function as one instruction and executes   it in one go.</li> <li><code>step</code> or <code>s</code>: Executes the next line, but if it contains a function call,   <code>step</code> will go into that function so you can continue debugging inside it.</li> <li><code>finish</code>: Runs until the current function is finished.</li> <li><code>continue</code> or <code>c</code>: Continues execution until the next breakpoint or   watchpoint.</li> <li><code>until lineno</code>: Continues execution until a line number greater than the   current one is reached. Useful for loops.</li> </ul> <p>Remember that you can use the <code>help</code> command in GDB to get information about any other command.</p>"},{"location":"user_guide/debugging/#inspecting-variables-and-registers","title":"Inspecting Variables and Registers","text":"<p>You can inspect the state of your program by examining variables and registers:</p> <ul> <li><code>print variable</code> or <code>p variable</code>: Prints the current value of the specified   variable.</li> <li><code>info registers</code>: Shows the current state of all CPU registers.</li> <li><code>info register regname</code>: Shows the current state of a specific CPU register.</li> <li><code>print gpio_reg-&gt;CTRL</code>: Shows the value of a register</li> </ul> <p>Tip</p> <p>If you get an error like:</p> <pre><code>Cannot access memory at address ???\n</code></pre> <p>This happens because GDB is limiting access to memory that is known at link time and is apart of the binary's structure. But if a user wants to access peripheral memory not associated with RAM or Flash memory then they can execute this command:</p> <pre><code>set mem inaccessible-by-default off\n</code></pre>"},{"location":"user_guide/debugging/#setting-breakpoints-and-watchpoints","title":"Setting Breakpoints and Watchpoints","text":"<p>Breakpoints allow you to pause program execution at a particular point, and watchpoints let you pause execution whenever a particular variable changes:</p> <ul> <li><code>break function</code> or <code>b function</code>: Sets a breakpoint at the beginning of the   specified function.</li> <li><code>break filename:lineno</code> or <code>b filename:lineno</code>: Sets a breakpoint at a   specific line in a specific file.</li> <li><code>watch variable</code>: Sets a watchpoint on a variable. The program will stop   executing whenever the variable's value changes.</li> <li><code>info breakpoints</code>: Lists all the breakpoints that are currently set.</li> <li><code>delete n</code>: Deletes breakpoint number <code>n</code>. Use <code>info breakpoints</code> to see   breakpoint numbers.</li> <li><code>delete</code>: Deletes all breakpoints if used without a number.</li> </ul>"},{"location":"user_guide/debugging/#flashing-a-device-using-gdb","title":"Flashing a Device using GDB","text":"<p>In GDB, you can also use the <code>load</code> command to flash your device. The <code>load</code> command automatically uses the target specified when you started the GDB session.</p> <pre><code>(gdb) load\n</code></pre> <p>This command will load the program onto your device.</p> <p>You can build the elf file in another terminal, then run <code>load</code> again to update the program. It may or may not reset the core back to the start so <code>monitor reset halt</code> may be needed.</p>"},{"location":"user_guide/error_handling/","title":"\ud83e\udea4 Error Handling in libhal using Boost.LEAF","text":"<p>Libhal uses Boost.LEAF for error handling. Boost.LEAF is a lightweight error handling library for C++11. It is designed for maximum efficiency and does not require dynamic memory allocations, even with heavy payloads. It can be used with or without exception handling and supports multi-thread programming.</p>"},{"location":"user_guide/error_handling/#basic-concepts","title":"Basic Concepts","text":"<p>Boost.LEAF introduces a few key concepts for error handling:</p> <ul> <li> <p>Error Objects: These are instances of any type that you want to associate   with an error. They can be error codes, strings, or any other type of object   that provides information about the error.</p> </li> <li> <p>Context: This is a scope where error objects can be loaded and associated   with a specific error. It is usually local to a <code>try_handle_all</code>,   <code>try_handle_some</code>, or <code>try_catch</code> scope.</p> </li> <li> <p>Error ID: This is a unique identifier for an error. It is generated when   an error is reported using <code>new_error</code> or <code>exception</code>.</p> </li> </ul>"},{"location":"user_guide/error_handling/#error-handling-process","title":"Error Handling Process","text":"<p>The error handling process in Boost.LEAF involves the following steps:</p> <ol> <li> <p>Detecting an Error: When an error is detected in your code, you can    report it by calling <code>new_error</code> or <code>exception</code>. These functions generate a    new error ID and return it. You can also pass any number of error objects to    these functions to associate them with the error.</p> </li> <li> <p>Loading Error Objects: Error objects can be loaded into an active context    using the <code>load</code> function. These objects become associated with a specific    error ID. If storage is not available, the error objects are discarded.</p> </li> <li> <p>Handling Errors: When an error is reported, it is forwarded up the call    stack until it reaches an error-handling scope. This scope probes the context    for any error objects associated with the error ID and processes a list of    user-provided error handlers. The first handler that can be supplied with the    available error objects is called to handle the error.</p> </li> </ol>"},{"location":"user_guide/error_handling/#boostleaf-aliases","title":"Boost.LEAF Aliases","text":"<p>libhal creates aliases for a few of the APIs in Boost.LEAF to shorten their names and use the <code>hal</code> namespace. The mapping can be found in libhal/error.hpp.</p> <p>Including <code>libhal/error.hpp</code> will pull in all of the Boost.LEAF libraries, so if you prefer to use them directly, you can do so.</p>"},{"location":"user_guide/error_handling/#example","title":"Example","text":"<p>Here is an example of how you can use Boost.LEAF for error handling in libhal:</p> <pre><code>#include &lt;libhal/error.hpp&gt;\n\nenum class error_code\n{\n    bad_command_line = 1,\n    open_error,\n    read_error,\n    size_error,\n    eof_error,\n    output_error\n};\n\nhal::result&lt;void&gt; do_something()\n{\n    // Some operation that may fail...\n    if (/* failure condition */)\n    {\n        return hal::new_error(open_error, leaf::e_errno{errno});\n    }\n\n    return {};\n}\n\nint main(int argc, char const *argv[])\n{\n    return hal::attempt_all(\n        []() -&gt; hal::result&lt;int&gt;\n        {\n            HAL_CHECK(do_something());\n            return 0;\n        },\n        [](hal::match&lt;error_code, open_error&gt;, leaf::e_errno const &amp;errn)\n        {\n            // Do something here\n            return 2;\n        },\n        []()\n        {\n            // Unknown error, handle it here\n            return 6;\n        });\n}\n</code></pre> <p>In this example, <code>do_something</code> is a function that may fail. If it fails, it reports an error by calling <code>new_error</code> and associates the error with an <code>open_error</code> error code and the system <code>errno</code>. The <code>main</code> function calls <code>do_something</code> and handles any errors that it reports. It uses <code>try_handle_all</code> to handle all errors and</p> <p>provides two error handlers. The first handler handles <code>open_error</code> errors and includes the system <code>errno</code>. The second handler handles any other errors.</p> <p>Please note that this is a basic example. Boost.LEAF provides many more features for error handling, such as error object composition, error object accumulation, and error object matching. You can use these features to create more sophisticated error handling systems.</p> <p>For more information, please refer to the Boost.LEAF documentation.</p>"},{"location":"user_guide/error_handling/#ram-usage-when-using-an-rtos","title":"RAM Usage when using an RTOS","text":"<p>To be written...</p>"},{"location":"user_guide/error_handling/#error-types-in-libhal","title":"Error Types in libhal","text":"<p>To be written...</p>"},{"location":"user_guide/fundamentals/","title":"\ud83e\uddf1 Fundamentals of libhal","text":"<p>At its core, libhal is a set of interfaces that correspond to hardware devices and peripherals. These interfaces use runtime polymorphism to decouple application logic from driver implementation details. This decoupling enables applications to run on any platform device that has the necessary components available.</p>"},{"location":"user_guide/fundamentals/#types-of-libraries","title":"Types of Libraries","text":"<p>In libhal, libraries are categorized into platform, utility, device, process, and application/operating system libraries.</p> <ul> <li>Processor Libraries: Contain the driver implementations for specific   processor. Generally, these libraries are not direct dependencies in an   application. These are depended upon by platform libraries, which use them to   make their own drivers work.</li> <li>Platform Libraries: Contain the driver implementations for specific   platforms. Every application that uses libhal will need one of these libraries   in order to work on any hardware.</li> <li>Utility Libraries: Software libraries to make writing libhal code easier.</li> <li>Device Libraries: Libraries containing drivers for specific hardware   devices or modules, such as a sensor, display, or a motor controller. They are   generally platform agnostic and should be usable on any system that can   support the driver requirements, memory requirements and performance   requirements.</li> <li>Process Libraries: Code that performs some work. This work usually   requires one or more drivers in order to work. This is similar to an   application on a device like a desktop computer or smartphone, but on an   embedded system. These processes can be called multiple times to perform work   or be used as the function for a thread.</li> <li>Application Libraries: Full applications that typically handle and take   over the whole system.</li> <li>RTOS Libraries: RTOS stands for Real Time Operating System and using these   libraries will enable multi-tasking and multi-threading capability to the   application.</li> <li>Software Libraries: These libraries are purely software-based and do not   directly interact with hardware. They provide useful utilities, data   structures, algorithms, and other software components that can be used across   different parts of an application. Examples might include an efficient   circular buffer implementation, a data structure for facilitating cross-driver   communication, or a driver that performs a specific algorithm on data. These   libraries are platform-agnostic and can be used in any application that meets   their requirements.</li> </ul>"},{"location":"user_guide/fundamentals/#interfaces","title":"Interfaces","text":"<p>Interfaces are the basic building blocks of libhal and enable the flexibility needed to be portable and flexible. An interface is a contract of functions that an implementing class must adhere to. Any software that implements (inherits) an interface must provide implementations for each function in the interface, otherwise the compiler will generate a compiler error.</p> <p>Not all libraries will implement an interface. Some drivers are</p>"},{"location":"user_guide/fundamentals/#driver-types","title":"Driver Types","text":"<ul> <li>Peripheral Drivers: Drivers for a platform that is embedded within the   platform or development board and therefore cannot be removed from the chip   and is fixed in number.</li> <li>Device Drivers: Drivers for devices external to a platform. In order to   communicate with such a device the platform must have the necessary peripherals   and peripheral drivers to operate correctly.</li> <li>Soft Drivers: Drivers that do not have any specific underlying hardware   associated with them. They are used to emulate, give context to, or alter the   behavior of interfaces.</li> </ul>"},{"location":"user_guide/fundamentals/#concrete-drivers","title":"Concrete Drivers","text":"<p>In libhal, not all drivers are designed to implement an interface. These drivers, referred to as \"Concrete Drivers\", are unique in that they typically do not contain virtual functions and cannot be passed in a generic form. Despite this, they play a crucial role in the library due to their specific functionality and support for certain hardware components.</p> <p>Concrete Drivers are fully realized classes that provide direct, specific functionality. They are designed to interact with a particular piece of hardware or perform a specific task, and their methods provide a direct interface to that hardware or task. Because they do not implement an interface, they cannot be used polymorphically like other drivers in libhal. However, their specificity allows them to provide robust, efficient, and direct control over their associated hardware.</p> <p>These drivers are particularly useful in scenarios where a specific piece of hardware or a specific task does not neatly fit into one of the existing libhal interfaces, or when the overhead of virtual functions is not desirable. Despite not conforming to a specific interface, Concrete Drivers adhere to the same design principles as other components of libhal, ensuring consistency and reliability across the library.</p> <p>In libhal, not all drivers are designed to implement an interface. These drivers, referred to as \"Concrete Drivers\", are unique in that they typically do not contain virtual functions and cannot be passed in a generic form. Despite this, they play a crucial role in the library due to their specific functionality and support for certain hardware components.</p> <p>Note that this isn't a distinct type outside of the list of Driver types mentioned above. Concrete drivers can be a peripheral, device and soft driver. They simply do not implement an interface.</p>"},{"location":"user_guide/fundamentals/#multi-interface-support","title":"Multi-Interface Support","text":"<p>Many Concrete Drivers can actually support multiple interfaces at once. For example, a driver for the RMD-X6 smart motor can act as a servo, a motor, a temperature sensor (for itself), a voltage sensor (for the bus it is connected to), a current sensor (for how much current it's consuming), and a rotation sensor (for its output shaft's position). To create these drivers from the concrete driver, an adaptor class must be used. These adaptor classes take the concrete class and use its methods in order to implement the interface APIs.</p>"},{"location":"user_guide/fundamentals/#adaptor-factory-functions","title":"Adaptor Factory Functions","text":"<p>In libhal, there is a common language policy for adaptors. To create them you must call a factory function called <code>make_&lt;name of interface&gt;()</code> and it will return a <code>hal::result&lt;adaptor_object&gt;</code>. There is an overload for every driver that implements a particular interface. For example, in order to generate a servo from an RMD X6 servo object, it would look like this:</p> <pre><code>auto smart_servo_driver = HAL_CHECK(make_servo(rmd_x6_driver));\n</code></pre> <p>This approach allows for a consistent and efficient way to create adaptors for various interfaces from a single concrete driver. It ensures that the concrete driver can be utilized to its full potential, providing access to all its capabilities through the appropriate interfaces.</p>"},{"location":"user_guide/fundamentals/#return-types-halresultt-and-halstatus","title":"Return Types <code>hal::result&lt;T&gt;</code> and <code>hal::status</code>","text":"<p><code>hal::result&lt;T&gt;</code> is an alias for the <code>boost::leaf::result&lt;T&gt;</code> type. This type can either be the value T or an error. <code>hal::status</code> is simply a concise alias for the type <code>boost::leaf::result&lt;void&gt;</code>. See Boost.LEAF for more details about it and how it works.</p> <p><code>HAL_CHECK()</code> is a macro that takes an expression that evaluates to a <code>hal::result</code>.</p>"},{"location":"user_guide/interfaces/","title":"\ud83d\udd17 Interfaces in Software Development and libhal","text":"<p>In software development, an interface is a shared boundary across which two separate components of a computer program exchange information. The exchange can be between software, computer hardware, peripheral devices, humans, and combinations of these. Technically, it refers to a software component (a class, a module, etc.) that encapsulates a specific functionality and that can be used by other components.</p> <p>Interfaces work by specifying the methods that a class must implement, without including the implementation of the methods themselves. This allows different classes to implement the same interface in different ways, providing a level of abstraction between the interface and the implementation.</p> <p>In the context of libhal (Hardware Abstraction Layer Library), interfaces are used to define a standard way of interacting with different types of hardware. This makes the software portable because it can interact with the hardware through the interface, without needing to know the specifics of how the hardware is implemented. This means that if the underlying hardware changes, only the implementation of the interface needs to change, not the software that uses it.</p>"},{"location":"user_guide/interfaces/#driver-types-in-libhal","title":"Driver Types in libhal","text":""},{"location":"user_guide/interfaces/#digital","title":"Digital","text":"Input PinOutput PinInterrupt Pin <p>See API: <code>hal::input_pin</code></p> <p>The Input Pin interface (<code>hal::input_pin</code>) in libhal is used for reading the state of a digital input pin. This is useful in situations where you need to determine if the voltage on a pin is HIGH or LOW.</p> <p>In the libhal library, the Input Pin interface provides methods to configure the input pin according to the settings supplied and to read the state of the input pin.</p> <p>See API: <code>hal::output_pin</code></p> <p>The Output Pin interface in libhal is used for controlling the state of a digital output pin. This is useful in situations where you need to send a control signal or turn on or off an LED.</p> <p>In the libhal library, the Output Pin interface provides methods to configure the output pin according to the settings supplied, to set the state of the pin, and to read the current state of the output pin.</p> <p>See API: <code>hal::interrupt_pin</code></p> <p>The Interrupt Pin interface in libhal is used for automatically calling a function when a pin's state has transitioned. This is useful in situations where you need to respond to changes in the state of a pin.</p> <p>In the libhal library, the Interrupt Pin interface provides methods to configure the interrupt pin according to the settings supplied and to set the callback for when the interrupt occurs.</p>"},{"location":"user_guide/interfaces/#analog","title":"Analog","text":"ADC (Analog-to-Digital Converter)DAC (Digital-to-Analog Converter)PWM (Pulse Width Modulation) <p>See API: <code>hal::adc</code></p> <p>The ADC interface in libhal is used to convert an analog signal into a digital one. This is useful in situations where the hardware device is producing an analog signal, such as a sensor reading, but the software works with digital values.</p> <p>In the libhal library, the ADC interface provides methods to read the voltage from the ADC as a percentage of the reference voltage.</p> <p>See API: <code>hal::dac</code></p> <p>The DAC interface in libhal is used to convert a digital signal into an analog one. This is useful in situations where the software is producing digital values, but the hardware device requires an analog signal.</p> <p>In the libhal library, the DAC interface provides methods to write a voltage to the DAC, as a percentage of the reference voltage.</p> <p>See API: <code>hal::pwm</code></p> <p>The PWM interface in libhal is used to control the waveform generation of a square wave and its properties such as frequency and duty cycle. PWM is used for power control like motor control, lighting, transmitting signals to servos, sending telemetry and much more.</p> <p>In the libhal library, the PWM interface provides methods to set the PWM waveform frequency and duty cycle.</p>"},{"location":"user_guide/interfaces/#time-timers","title":"Time &amp; Timers","text":"TimerSteady Clock <p>See API: <code>hal::timer</code></p> <p>The Timer interface in libhal is used for scheduling events to occur after a specified amount of time. This is useful in situations where you need to perform an action after a certain amount of time has passed.</p> <p>In the libhal library, the Timer interface provides methods to check if the timer is running, cancel a scheduled event, and schedule a new event.</p> <p>See API: <code>hal::steady_clock</code></p> <p>The Steady Clock interface in libhal is used for a steady clock mechanism. This clock is steady meaning that subsequent calls to get the uptime of this clock cannot decrease as physical time moves forward and the time between ticks of this clock are constant and defined by the clock's frequency.</p> <p>In the libhal library, the Steady Clock interface provides methods to get the operating frequency of the steady clock and to get the current value of the steady clock.</p> <p>This completes the descriptions for all the interfaces in the libhal library. Each of these interfaces provides a way to interact with different types of hardware in a consistent and portable way, making it easier to write embedded software that can run on different platforms.</p>"},{"location":"user_guide/interfaces/#serial-communication-protocols","title":"Serial Communication Protocols","text":"SPI (Serial Peripheral Interface)I2C (Inter-Integrated Circuit)SerialCAN (Controller Area Network) <p>See API: <code>hal::spi</code></p> <p>The SPI interface in libhal is used for communication over a Serial Peripheral Interface (SPI). This is a synchronous serial communication interface specification used for short-distance communication, primarily in embedded systems.</p> <p>In the libhal library, the SPI interface provides methods to configure the SPI bus and perform an SPI transaction.</p> <p>See API: <code>hal::i2c</code></p> <p>The I2C interface in libhal is used for communication over an Inter-Integrated Circuit (I2C) bus. This is a multi-master, multi-slave, packet switched, single-ended, serial computer bus invented by Philips Semiconductor.</p> <p>In the libhal library, the I2C interface provides methods to configure the I2C bus and perform an I2C transaction.</p> <p>See API: <code>hal::serial</code></p> <p>The Serial interface in libhal is used for hardware that implements a serial protocol like UART, RS232, RS485, and others that use a similar communication protocol but may use different voltage schemes.</p> <p>In the libhal library, the Serial interface provides methods to configure the serial to match the settings supplied, to write data to the transmitter line of the serial port, to copy bytes from the working buffer into the passed buffer, and to flush the working buffer.</p> <p>Unfortunately, I encountered an error while trying to access the Steady Clock interface file in the libhal repository. I'll try again to retrieve its content.</p> <p>See API: <code>hal::can</code></p> <p>The CAN interface in libhal is used for communication over a Controller Area Network (CAN bus). This is a robust vehicle bus standard designed to allow microcontrollers and devices to communicate with each other's applications without a host computer.</p> <p>In the libhal library, the CAN interface provides methods to configure the CAN bus, send a CAN message, and set a message reception handler.</p>"},{"location":"user_guide/interfaces/#actuators","title":"Actuators","text":"MotorServo <p>See API: <code>hal::motor</code></p> <p>The Motor interface in libhal is used for controlling an open loop rotational actuator. This can represent a variety of things such as a driver for a motor controller IC like the DRV8801, a driver for a motor with an integrated controller &amp; serial interface, a unidirectional motor controlled by a single transistor, or a servo with open loop motor control.</p> <p>In the libhal library, the Motor driver provides methods to apply power to the motor. The power applied is a percentage of the total available power.</p> <p>See API: <code>hal::servo</code></p> <p>The Servo interface in libhal is used for controlling a closed loop position controlled rotational actuator. Servos are devices that can rotate to a specified position.</p> <p>In the libhal library, the Servo interface provides methods to set the position of the servo's output shaft.</p>"},{"location":"user_guide/interfaces/#sensors","title":"Sensors","text":"Temperature SensorAccelerometerGyroscopeMagnetometerDistance SensorRotation Sensor <p>See API: <code>hal::temperature_sensor</code></p> <p>The Temperature Sensor interface in libhal is used for reading the current temperature measured by a device. This is useful in situations where you need to monitor the temperature of a device or environment.</p> <p>In the libhal library, the Temperature Sensor interface provides a method to read the current temperature.</p> <p>See API: <code>hal::accelerometer</code></p> <p>The Accelerometer interface in libhal is used for sensing acceleration. Accelerometers are devices that measure the rate of change of velocity with respect to time (acceleration).</p> <p>In the libhal library, the Accelerometer interface provides methods to read the acceleration sensed by the device in the X, Y, and Z axes.</p> <p>Accelerometers are commonly used to determine orientation or tilt of an object.</p> <p>See API: <code>hal::gyroscope</code></p> <p>The Gyroscope interface in libhal is used for sensing angular velocity. Gyroscopes are devices that measure the rotational speed around an axis.</p> <p>In the libhal library, the Gyroscope interface provides methods to read the angular velocity sensed by the device in the X, Y, and Z axes.</p> <p>See API: <code>hal::magnetometer</code></p> <p>The Magnetometer interface in libhal is used for sensing magnetic field strength. Magnetometers are devices that measure the strength and direction of a magnetic field.</p> <p>In the libhal library, the Magnetometer interface provides methods to read the magnetic field strength sensed by the device in the X, Y, and Z axes.</p> <p>Such devices are commonly used as a compass in order to provide heading information to a device.</p> <p>See API: <code>hal::distance_sensor</code></p> <p>The Distance Sensor interface in libhal is used for sensing linear distance. Distance sensors can be used in a variety of applications, such as measuring the distance to an object or determining the position of an object.</p> <p>In</p> <p>the libhal library, the Distance Sensor interface provides methods to read the current distance measured by the device.</p> <p>See API: <code>hal::rotation_sensor</code></p> <p>The Rotation Sensor interface in libhal is used for sensing a single axis of rotation. Rotation sensors can be used in a variety of applications, such as measuring the rotation to an object or determining the angular position of an object.</p> <p>In the libhal library, the Rotation Sensor interface provides methods to read the current angle, in degrees, measured by the device.</p> \u23f3 Current Sensor\u23f3 Voltage Sensor\u23f3 GPS <p>API not available yet</p> <p>A Current Sensor driver in libhal would be used for sensing electrical current. Current sensors are devices that detect the current of current flowing through a circuit.</p> <p>In the libhal library, the Current Sensor interface provides methods to read the current as a unit of <code>amperes</code>.</p> <p>API not available yet</p> <p>A Voltage Sensor driver in libhal would be used for sensing electrical voltage. Voltage sensors are devices that can measure the voltage potential difference between two points in an electrical circuit. When available, the Voltage Sensor driver would provide methods to read the voltage sensed by the device.</p> <p>In the libhal library, the Voltage Sensor interface provides methods to read the current as a unit of <code>volts</code>.</p> <p>API not available yet</p> <p>A GPS (Global Positioning System) driver in libhal would be used for receiving and interpreting GPS signals, which provide geolocation and time information to a GPS receiver anywhere on or near the Earth. When available, the GPS driver would provide methods to read the current location, speed, time, and other relevant data from the GPS signals.</p> <p>In the libhal library, the GPS interface provides methods to read location in longitude and latitude, get the current time, and get velocity.</p> <p>NOTE: that more investigation is needed to determine what fields make sense for this sensor and if it should be broken up into multiple interfaces like <code>hal::geolocation</code>, <code>hal::heading</code>, <code>hal::clock</code> and <code>hal::velocity</code>.</p>"},{"location":"user_guide/interfaces/#the-myth-about-virtual-understanding-dynamic-polymorphism-in-c","title":"The Myth about Virtual: Understanding Dynamic Polymorphism in C++","text":"<p>There's a common misconception in the C++ community that dynamic polymorphism inherently requires dynamic memory (heap memory), and that it's slower or more memory-intensive than other forms of polymorphism. This is not necessarily true. Let's debunk these myths.</p>"},{"location":"user_guide/interfaces/#dynamic-polymorphism-and-dynamic-memory","title":"Dynamic Polymorphism and Dynamic Memory","text":"<p>Dynamic polymorphism in C++ is achieved through virtual functions, which allow us to override functions in derived classes. This provides a way to use a base class pointer or reference to call the appropriate function based on the actual object type at runtime.</p> <p>While it's true that dynamic memory can be used in conjunction with dynamic polymorphism (for instance, when creating objects of derived classes and storing them in base class pointers), it's not a requirement. You can have dynamic polymorphism without dynamic memory.</p> <p>Consider a scenario where you have a base class <code>Base</code> and a derived class <code>Derived</code>. If you have a function that takes a reference to <code>Base</code>, you can pass an instance of <code>Derived</code> to that function without needing to allocate <code>Derived</code> on the heap:</p> <pre><code>void someFunction(Base&amp; baseRef) {\n    baseRef.someVirtualFunction();\n}\n\nDerived derived;\nsomeFunction(derived);  // No dynamic memory involved\n</code></pre> <p>In this case, <code>someFunction</code> will call the correct version of <code>someVirtualFunction</code> based on the actual type of the object, even though it's passed as a reference to <code>Base</code>. This is dynamic polymorphism in action, without any dynamic memory.</p>"},{"location":"user_guide/interfaces/#performance-of-dynamic-polymorphism","title":"Performance of Dynamic Polymorphism","text":"<p>Another myth is that dynamic polymorphism is slower than other forms of polymorphism, such as using a struct with function pointers (akin to C-style interfaces). In reality, the performance difference is negligible in most cases.</p> <p>When a virtual function is called, the compiler needs to look up the function address in the virtual table (vtable) of the object. This is essentially a pointer dereference, which is the same operation needed to call a function through a function pointer in a struct. Therefore, the performance of these two approaches is comparable.</p>"},{"location":"user_guide/interfaces/#memory-overhead-of-virtual-polymorphism","title":"Memory Overhead of Virtual Polymorphism","text":"<p>The memory overhead of dynamic polymorphism is also often overstated. Each class with virtual functions has a vtable, which is essentially a static array of function pointers. This vtable is shared among all instances of the class, so it doesn't increase the per-instance memory overhead.</p> <p>The vtable does increase the size of the binary, but the increase is usually small. Each vtable entry is just a function pointer. For a class hierarchy with a reasonable number of virtual functions, this overhead is typically negligible.</p> <p>In addition to the function pointers, the vtable contains two more pointers: one for the parent class's vtable (for supporting inheritance) and one for Run-Time Type Information (RTTI, used for <code>dynamic_cast</code> and <code>typeid</code>). These are fixed overheads per class, not per object.</p> <p>In conclusion, while dynamic polymorphism in C++ does have some overhead, it's often smaller than people think. It doesn't inherently require dynamic memory, its performance is comparable to other forms of polymorphism, and its memory overhead is typically small. Therefore, it's a powerful tool for creating flexible and reusable code in C++.</p>"},{"location":"user_guide/policy/","title":"\u2696\ufe0f Policies &amp; FAQ","text":""},{"location":"user_guide/policy/#1-ensuring-consistency-across-platforms","title":"1. Ensuring Consistency Across Platforms","text":"<p>To maintain a consistent interface across platforms, libhal adopts:</p> <ol> <li>Clearly articulated rules and interface API documentation. This ensures every    potential input produces a predictable behavior.</li> <li>Testing mechanisms that ensure adherence to these standards.</li> </ol> <p>While libhal covers the documentation aspect, our CI integration doesn't yet encompass all testing facets, simulated or real-world. We are in the process of designing a compliance test suitable both for device testing and CI inclusion. Presently, the onus is on manual testing and meticulous inspection.</p> <p>Regarding unit tests: Although beneficial for purely software libraries, they're not always feasible for embedded systems. Once you mock components like i2c or input pins, the actual device testing veers towards simulation. This method is viable post verifying the device compatibility, solidifying the code behavior through unit tests. High-level conceptual and application codes can harness such tests, but unit testing often misaligns with low-level drivers.</p>"},{"location":"user_guide/policy/#2-driver-development-in-libhal","title":"2. Driver Development in libhal","text":"<p>How are these drivers created? Do new products gain immediate support?</p> <p>Our developers craft code by hand. Fully automated firmware driver solutions either fall short on efficiency or fail to span multiple devices. However, for devices adhering to standards like NMEA or JEDEC, automation holds potential. We're also considering tools that process SVD files into bit mask ranges, assuming no licensing complications arise.</p>"},{"location":"user_guide/policy/#3-oems-stance-on-libhal-software","title":"3. OEM's Stance on libhal Software","text":"<p>Does libhal have defenses against potential vendor objections?</p> <p>Using OEM-developed SDKs can be tricky due to restrictive licensing. For instance, SDKs from NXP or STM mandate their code only run on their specific devices. Some chips might mirror the architecture of another, but licensing can inhibit cross-utilization.</p> <p>Our safeguard? Any software we integrate is crafted by our engineers, strictly based on publicly accessible OEM manuals. We're mindful of potential exceptions and will handle them case-by-case.</p>"},{"location":"user_guide/policy/#4-vendor-sdk-utilization-in-libhal","title":"4. Vendor SDK Utilization in libhal","text":"<p>How does libhal tackle licensed APIs? What does it mean for the end developer?</p> <p>Currently, libhal steers clear of SDKs with confining licenses or those misaligned with Apache 2.0 or its equivalents. This includes licenses from NXP and STM. However, SDKs from Espressif Systems (with Apache 2.0) are potentially usable.</p>"},{"location":"user_guide/policy/#5-dealing-with-devices-lacking-public-manuals","title":"5. Dealing with Devices Lacking Public Manuals","text":"<p>Devices without public user manuals typically don't get a libhal library. Here's why:</p> <ol> <li>It risks unintentional exposure of proprietary device information.</li> <li>Without a manual, the code operates like a black box, turning debugging into    a reverse-engineering puzzle.</li> </ol> <p>We can craft drivers for such devices, but their source code would remain confidential. Libhal predominantly focuses on fostering open-source libraries.</p>"}]}